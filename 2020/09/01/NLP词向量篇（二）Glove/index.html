<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>NLP词向量篇（二）Glove | BaiDing's blog</title><meta name="description" content="NLP词向量篇（二）Glove"><meta name="keywords" content="深度学习,NLP基础知识"><meta name="author" content="白丁"><meta name="copyright" content="白丁"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://raw.githubusercontent.com/BaiDingHub/Blog_images/master/BlogSource/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="crossorigin"/><link rel="preconnect" href="http://ta.qq.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="x-1ef6P_miWkq-RJn_fmjd3KYumrXANNXYzK1myaLf0"/><meta name="baidu-site-verification" content="guD6l44Chk"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="NLP词向量篇（二）Glove"><meta name="twitter:description" content="NLP词向量篇（二）Glove"><meta name="twitter:image" content="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/cover.png?raw=true"><meta property="og:type" content="article"><meta property="og:title" content="NLP词向量篇（二）Glove"><meta property="og:url" content="http://baidinghub.github.io/2020/09/01/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/"><meta property="og:site_name" content="BaiDing's blog"><meta property="og:description" content="NLP词向量篇（二）Glove"><meta property="og:image" content="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/cover.png?raw=true"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://baidinghub.github.io/2020/09/01/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/"><link rel="prev" title="NLP词向量篇（三）FastText" href="http://baidinghub.github.io/2020/09/02/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89FastText/"><link rel="next" title="NLP词向量篇（一）Word2Vec" href="http://baidinghub.github.io/2020/09/01/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89Word2Vec/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-162698439-1', 'auto');
ga('send', 'pageview');
</script><script src="https://tajs.qq.com/stats?sId=66540586" charset="UTF-8"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"4JGH9NW4XG","apiKey":"41cdb6d9ec4d21196956524e9c985b36","indexName":"baiding","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/avatar.png?raw=true" onerror="onerror=null;src='https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/friend_404.gif?raw=true'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">98</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">61</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 存档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于作者</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Glove-Global-vectors-for-word-representation"><span class="toc-text">Glove: Global vectors for word representation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内容分析"><span class="toc-text">内容分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#共现矩阵"><span class="toc-text">共现矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#共现矩阵与词向量的关系"><span class="toc-text">共现矩阵与词向量的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Loss函数的确定"><span class="toc-text">Loss函数的确定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#训练过程"><span class="toc-text">训练过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模型效果"><span class="toc-text">模型效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1、Introduction"><span class="toc-text">1、Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、Related-Work"><span class="toc-text">2、Related Work</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Matrix-Factorization-Methods"><span class="toc-text">2.1 Matrix Factorization Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Shallow-Window-Based-Methods"><span class="toc-text">2.2 Shallow Window-Based Methods.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、The-GloVe-Model"><span class="toc-text">3、The GloVe Model</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Relationship-to-Other-Models"><span class="toc-text">3.1 Relationship to Other Models</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Complexity-of-the-model"><span class="toc-text">3.2 Complexity of the model</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、Experiments"><span class="toc-text">4、Experiments</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Evaluation-methods"><span class="toc-text">4.1 Evaluation methods</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-Word-analogies"><span class="toc-text">4.1.1 Word analogies</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-Word-similarity"><span class="toc-text">4.1.2 Word similarity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-Named-entity-recognition"><span class="toc-text">4.1.3 Named entity recognition</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Corpora-and-training-details"><span class="toc-text">4.2 Corpora and training details</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Results"><span class="toc-text">4.3 Results</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Model-Analysis-Vector-Length-and-Context-Size"><span class="toc-text">4.4 Model Analysis: Vector Length and Context Size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Model-Analysis-Corpus-Size"><span class="toc-text">4.5 Model Analysis: Corpus Size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-Model-Analysis-Run-time"><span class="toc-text">4.6 Model Analysis: Run-time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-Model-Analysis-Comparison-with-word2vec"><span class="toc-text">4.7 Model Analysis: Comparison with word2vec</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、Conclusion"><span class="toc-text">5、Conclusion</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/cover.png?raw=true)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">BaiDing's blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 存档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于作者</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">NLP词向量篇（二）Glove</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-09-01 15:20:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-09-01</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-12-02 11:11:09"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-12-02</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">NLP基础知识</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">1.4k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 5 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/09/01/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><meta name="referrer" content="no-referrer"/>



<h1 id="Glove-Global-vectors-for-word-representation"><a href="#Glove-Global-vectors-for-word-representation" class="headerlink" title="Glove: Global vectors for word representation"></a>Glove: Global vectors for word representation</h1><blockquote>
<p>时间：2014年</p>
<p>关键词：NLP, Word Embedding</p>
<p>论文位置：<a href="https://www.aclweb.org/anthology/D14-1162.pdf" target="_blank" rel="noopener">https://www.aclweb.org/anthology/D14-1162.pdf</a></p>
<p>引用：Pennington J, Socher R, Manning C D. Glove: Global vectors for word representation[C]//Proceedings of the 2014 conference on empirical methods in natural language processing (EMNLP). 2014: 1532-1543.</p>
</blockquote>
<p><strong>摘要：</strong>最近学习词向量方法已经成功地利用向量算法捕获了细粒度的语义和句法规律，但这些规律的起源仍然不清楚。我们分析并明确了在单词向量中出现这种规律所需的模型属性。结果是一个新的全局双线性对数回归模型，它结合了文献中两个主要模型族的优点:全局矩阵分解和局部上下文窗口方法。我们的模型有效地利用了统计信息，只训练了词-词共生矩阵矩阵中的非零元素，而不是对整个稀疏矩阵或大型语料中的单个上下文窗口进行训练。该模型产生了一个有意义子结构的向量空间，在最近的单词类比任务中准确率维75%就证明了这一点。在相似度任务和命名实体识别方面也优于相关模型。</p>
<p><strong>索引</strong>- 自然语言处理，词向量</p>
<h2 id="内容分析"><a href="#内容分析" class="headerlink" title="内容分析"></a>内容分析</h2><p> &emsp;&emsp; 上一节，我们也提到了，Word2Vec关注的是词的局部信息，而忽略了整个语料库的全局信息，GloVe就从这个角度出发，将语料库的全局信息，引入到词向量中，也可以说，GloVe仅使用了全局信息来获得词向量。</p>
<h3 id="共现矩阵"><a href="#共现矩阵" class="headerlink" title="共现矩阵"></a><strong>共现矩阵</strong></h3><p> &emsp;&emsp; 那么，语料库的全局信息是什么呢？共现矩阵。令word-word 共现矩阵表示为$ X$ ，其中$ X_{ij}$ 表示单词$ j$ 出现在单词$ i$ 的上下文中的次数。令$ X_i = \sum_k X_{ik}$ 表示出现在单词$ i$ 的上下文的词的总数。最后，令$ P_{ij} = P(j|i) = X_{ij}/X_i$ 表示单词$ j$ 出现在单词$ i$ 的上下文中的概率。</p>
<h3 id="共现矩阵与词向量的关系"><a href="#共现矩阵与词向量的关系" class="headerlink" title="共现矩阵与词向量的关系"></a><strong>共现矩阵与词向量的关系</strong></h3><p> &emsp;&emsp; 共现矩阵从语料库的角度统计着词之间的关系，当我们建立了共现矩阵与词向量之间的关系后，我们就可以利用共现矩阵构建词向量。</p>
<p> &emsp;&emsp; 拿单词$ i$ 和单词$ j$ 为例，如果我们想要知道这两个单词要表达的是什么，我们就需要找到跟这两个词相近的其他词$ k$ ，根据共现矩阵，我们可以得到词$ k$ 在单词$ i$ 上下文出现的概率$ P_{ik}$ ，同样的，我们可以得到$ P_{jk}$ 。如果该单词$ k$ 与单词$ i$ 意思接近，那么 $ P_{ik}$ 就会比较大，而$ P_{jk}$ 就比较小，所以$ P_{ik}/P_{jk}$ 就会很大，反过来，如果该单词$ k$ 与单词$ j$ 意思接近，$ P_{ik}/P_{jk}$ 就会很小。因此，$ P_{ik}/P_{jk}$ 可以反映这三个词之间的关系，我们可以构建这样的模型：</p>
<script type="math/tex; mode=display">
F(w_i,w_j,\tilde{w_k}) = \frac{P_{ik}}{P_{jk}} \tag{1}</script><p> &emsp;&emsp; 这样构造模型的话，$ F$ <strong>函数就要处理三维向量，复杂度很高，因此要想办法将其参数转换成标量以降低生成词向量的复杂度</strong>，转换后（转换过程看Sec 3.1），得到：</p>
<script type="math/tex; mode=display">
F((w_i - w_j)^T \tilde{w_k}) = \frac{F(w_i^T \tilde{w_k})}{F(w_j^T \tilde{w_k})} \tag{4}</script><p> &emsp;&emsp; 而得到了这个模型后，我们就又有了其他的策略，我们可以直接构建这样的等式：</p>
<script type="math/tex; mode=display">
F(w_i^T\tilde{w_k}) = P_{ik} = \frac{X_{ik}}{X_i} \tag{5}</script><p> &emsp;&emsp; 所以，我们只要解决这个就可以了。</p>
<p> &emsp;&emsp; 此时，我们的函数模型$ F$ 仍然未知，于是，作者指定$ F= \exp$ 。之后，为了将$ F$ 转换成一个对称的函数，即$ w_i$ 和$ \tilde{w_k}$ 参数的位置可以交换，交换后结果不变，作者又对$ F$ 进行了一定的变换，推导过程看Sec 3.1后半部分，转换后得到：</p>
<script type="math/tex; mode=display">
w_i^T \tilde{w_k} + b_i + \tilde{b_k} = \log(X_{ik}) \tag{7}</script><p> &emsp;&emsp; 由于共现矩阵中稀疏性巨大，存在大量的空值，因此我们需要将右式转换成$ log(1+X_{ik})$ 。</p>
<h3 id="Loss函数的确定"><a href="#Loss函数的确定" class="headerlink" title="Loss函数的确定"></a><strong>Loss函数的确定</strong></h3><p> &emsp;&emsp; 既然，我们得到了词向量与共现矩阵的关系，我们就需要在训练过程中，使得得到的词向量逼近上面的等式，由此，可以得到初步的Loss函数：</p>
<script type="math/tex; mode=display">
J = \sum_{i,j=1}^V (w_i^T \tilde{w_j} + b_i + \tilde{b_j} - \log(X_{ij}))</script><p> &emsp;&emsp; 这样的损失函数简单，但会引来一个问题，<strong>那就是该损失函数，对频率小的单词对和频率大的单词对给予相同的权重，这是不合理的</strong>，因为频率小的单词对存在很多的噪音，会使得模型的训练变得很复杂，因此，<strong>我们需要给不同的单词对分配不同的权重</strong>，即：</p>
<script type="math/tex; mode=display">
J = \sum_{i,j=1}^V f(X_{ij})(w_i^T \tilde{w_j} + b_i + \tilde{b_j} - \log(X_{ij}) \tag{8})</script><p> &emsp;&emsp; 此时，$ f(X_{ij})$ 应该满足一些性质：</p>
<ol>
<li><strong>$ f(0) =0$ ，如果$ f$ 是一个连续函数的话，当$ x \to 0$ 的时候，他应该也趋于0，使得$ \lim_{x \to 0}f(x) \log^2 x$ 有解。</strong></li>
<li><strong>$ f(x)$ 应该是非递减的，这样，稀有的共现情况就不会给予过大的权重</strong></li>
<li><p><strong>当$ x$ 比较大时，$ f(x)$ 应该相对小一些，这样比较频繁的共现情况也就不会给予过大的权重</strong></p>
<p>&emsp;&emsp; 最后，作者给出了一个权重函数：</p>
<script type="math/tex; mode=display">
f(x)=
\begin{cases}
(x/x_{max})^{\alpha} & & if\ x<x_{max}\\
1 & & otherwise \\
\end{cases} \\
\tag{9}</script><p>&emsp;&emsp; 实验中，一般取$ x_{max} = 100, \alpha = 0.75$ 。</p>
</li>
</ol>
<h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a><strong>训练过程</strong></h3><p><strong>1、构建共现矩阵</strong></p>
<p> &emsp;&emsp; 在这一步，我们需要根据语料库来构建共现矩阵。</p>
<p><strong>2、初始化</strong></p>
<p> &emsp;&emsp; 初始化词向量矩阵，这一步要初始化两个词向量矩阵，一个是$ W$ ，一个是$ \tilde{W}$ ，分别对应损失函数中的词向量$ w_i$ 和$ \tilde{w_j}$ 。但其实，这两个矩阵是等价的，只是由于初始化不同导致最后结果有一点点的不同。这两个词向量我们都可以作为最后的词向量矩阵输出。作者给出的结果是$ W+\tilde{W}$ 。</p>
<p> <strong>3、梯度传播</strong></p>
<p> &emsp;&emsp; 由于损失函数已知，各类参数已经初始化完毕，因此我们要根据损失函数进行梯度的反向传播，来对两个词向量矩阵进行更新。</p>
<h3 id="模型效果"><a href="#模型效果" class="headerlink" title="模型效果"></a>模型效果</h3><p><strong>单词类比任务</strong></p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/1.jpg?raw=true"  alt="1"></p>
<h2 id="1、Introduction"><a href="#1、Introduction" class="headerlink" title="1、Introduction"></a>1、Introduction</h2><p> &emsp;&emsp; 语言的语义向量空间模型用一个实值向量表示每个单词。这些向量可以作为各种应用的特征，如信息检索(Manning et al.，  2008)、文档分类(Sebastiani, 2002)、问题回答(Tellex et al.， 2003)、命名实体识别(Turian et al.，  2010)和解析(Socher et al.， 2013)。</p>
<p> &emsp;&emsp; 大多数词向量方法依赖于词向量对之间的距离或角度作为评价这一组词表示的内在质量的主要方法。最近，Mikolov等人(2013c)提出了一种新的基于单词类比的评估方案，该方案不是通过检查单词向量之间的标量距离，而是通过检查它们的不同维度的差异来探测单词向量空间的精细结构。例如，“king is to queen as man is to woman”这一类比，应该用向量方程king  - queen = man - woman来编码在向量空间中。这种评估方案有利于产生意义维度的模型，从而捕获词向量的多聚类思想(Bengio, 2009)。</p>
<p> &emsp;&emsp; 学习词向量的两大类主要模型是:1）全局矩阵分解方法，如潜在语义分析(LSA) (Deerwester et al.，  1990)和2）局部上下文窗口方法，如Mikolov et al.  (2013c)的skip-gram模型。目前，<strong>这两个模型族都有明显的缺陷。虽然像LSA这样的方法有效地利用了统计信息，但它们在单词类比任务上做得相对较差，这表明它们是次优的向量空间结构。像skip-gram这样的方法可能在类比任务上做得更好，但是它们没有很好地利用语料库的统计，因为它们是在单独的局部上下文窗口上训练，而不是在全局共现计数矩阵上训练。</strong></p>
<p> &emsp;&emsp; 在这项工作中，我们分析了生成有意义的线性方向所必需的模型属性，并论证了全局对数-双线性回归模型适用于这样做。我们提出了一种特殊的加权最小二乘模型，该模型训练全局词-词共现计数，从而有效地利用了统计数据。该模型产生一个具有有意义子结构的单词向量空间，在单词类比数据集上其75%的精度的SOTA证明了这一点。我们还证明了我们的方法在几个单词相似度任务和一个通用的命名实体识别(NER)基准测试上优于其他当前的方法。</p>
<h2 id="2、Related-Work"><a href="#2、Related-Work" class="headerlink" title="2、Related Work"></a>2、Related Work</h2><h3 id="2-1-Matrix-Factorization-Methods"><a href="#2-1-Matrix-Factorization-Methods" class="headerlink" title="2.1 Matrix Factorization Methods"></a>2.1 Matrix Factorization Methods</h3><p> &emsp;&emsp; 用于生成低维词向量的矩阵分解方法的根源可以追溯到LSA。这些方法利用低秩近似来分解捕获关于语料库的统计信息的大型矩阵。此类矩阵捕获的特定类型的信息因应用程序而异。在LSA中，矩阵是“term-document”类型，即行对应单词或术语，列对应语料库中的不同文档。另外，the Hyperspace Analogue to Language(HAL)  (Lund和Burgess, 1996)，利用了“term-term”类型的矩阵，即，行和列对应于单词，实体对应于一个给定单词在另一个给定单词上下文中出现的次数。</p>
<p> &emsp;&emsp; HAL和相关方法的一个主要问题就是在相似度测量时，那些最常见的单词会造成数量上的不均衡，比如有the或and的共线次数，这会对他们的相似度测量有很大印象，但这些单词并没有语义上的相关性。有许多技术可以解决HAL的这一缺点，如COALS(Rohde et al.， 2006)，其中共现矩阵首先通过基于熵或相关的归一化进行变换。这种变换的一个优点是对原始共现计数（对于规模合理的语料库，共现计数可能跨度为8或9个数量级）进行压缩，使其在更小的间隔内更均匀地分布。各种新的模型也在采用这种方法，包括一项研究(Bullinaria和Levy, 2007)表明positive pointwise mutual information (PPMI)是一种很好的转换。最近，基于Hellinger PCA (HPCA)的平方根类型变换(Lebret和Collobert, 2014)被认为是学习单词表示的一种有效方法。</p>
<h3 id="2-2-Shallow-Window-Based-Methods"><a href="#2-2-Shallow-Window-Based-Methods" class="headerlink" title="2.2 Shallow Window-Based Methods."></a>2.2 Shallow Window-Based Methods.</h3><p> &emsp;&emsp; 另一种方法是学习有助于在局部上下文窗口中进行预测的词向量。例如，Bengio等人(2003)引入了一种学习单词向量表示的模型，作为语言建模的简单神经网络架构的一部分。Collobert和Weston(2008)将词向量训练从下游训练目标中脱离出来，为Collobert  et al .(2011)的工作创作了条件，其使用一个词完整的上下文来学习该词的representation，而不是像语言模型那样只使用前面的上下文。</p>
<p> &emsp;&emsp; 最近，整个神经网络结构对于学习有用的单词表示的重要性受到了质疑。Mikolov等人(2013a)的skip-gram和CBOW模型提出了一种简单的基于两个词向量的内积的单层架构。Mnih和Kavukcuoglu(2013)也提出了密切相关的向量对数-双线性模型vLBL和ivLBL,  Levy等人(2014)提出了基于PPMI度量的显式词向量。</p>
<p> &emsp;&emsp; 在skip-gram和ivLBL模型中，目标是 给定单词，预测单词的上下文，而在CBOW和vLBL模型中，目标是 给定某单词的上下文，预测该单词。通过对词语类比任务的评价，这些模型证明了将语言模式作为词语向量之间的线性关系来学习的能力。</p>
<p> &emsp;&emsp; 与矩阵分解方法不同，the shallow window-based methods不能直接对语料库的共现统计进行操作。相反，这些模型在整个语料库中扫描上下文窗口，无法利用数据中大量的重复。</p>
<h2 id="3、The-GloVe-Model"><a href="#3、The-GloVe-Model" class="headerlink" title="3、The GloVe Model"></a>3、The GloVe Model</h2><p> &emsp;&emsp; <strong>出现在语料库中的词的统计数据是所有的用来学习词向量的非监督方法的信息的主要来源</strong>。尽管目前存在很多这样的方法，但<strong>仍然存在着问题，即如何发现这些统计数据的含义以及由此产生的词向量可能代表的意义</strong>。在这一节中，我们对这个问题作一些说明。我们利用我们的方法来构建一个新的词汇表示模型，我们称之为GloVe，用于Global Vectors，因为全局语料库统计数据是直接被模型捕获的。</p>
<p> &emsp;&emsp; 首先，先介绍以下要用到的符号。令word-word 共现矩阵表示为$ X$ ，其中$ X_{ij}$ 表示单词$ j$ 出现在单词$ i$ 的上下文中的次数。令$ X_i = \sum_k X_{ik}$ 表示出现在单词$ i$ 的上下文的词的总数。最后，令$ P_{ij} = P(j|i) = X_{ij}/X_i$ 表示单词$ j$ 出现在单词$ i$ 的上下文中的概率。</p>
<p> &emsp;&emsp; 我们从一个简单的例子开始，它展示了如何直接从共现概率中提取特定的语义。考虑两个词$ i$ 和$ j$ ，这两个词表示了一个特定的兴趣，具体一点，假设我们对热力学的概念感兴趣，我们可以取$ i  = ice$ ，$ j = steam$ 。我们可以通过研究这两个词与别的词$ k$ 的共现概率的比例来得到这些词的关系。对于与$ ice$ 而不是$ steam$ 有关的词$ k$ ，比如$ k = solid$ ，那么$ P_{ik}/P_{jk}$ 的比率会很大。类似地，对于与$ steam$ 有关而与$ ice$ 无关的单词$ k$ ，比方说$ k=gas$ ，其比值应该很小。对于像“water”或“fashion”这样既与ice有关又与steam无关的词，其比例应该接近于1。表1显示了大型语料库的这些概率及其比率，这些数字证实了这些预期。与原始概率相比，该比值能更好地区分相关词(solid  and gas)和不相关词(water and fashion)，也能更好地区分两个相关词。</p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/2.png?raw=true"  alt="2"></p>
<p> &emsp;&emsp; 上述的观点表明了，我们应该从共现概率比值出发去学习词向量，而不是概率值本身。比例$ P_{ik}/P_{jk}$ 取决于三个词$ i,j,k$ ，所以最一般的模型为：</p>
<script type="math/tex; mode=display">
F(w_i,w_j,\tilde{w_k}) = \frac{P_{ik}}{P_{jk}} \tag{1}</script><p> &emsp;&emsp; 其中，<strong>$ w \in \mathbb{R}^d$ 是词向量，$ \tilde{w} \in \mathbb{R}^d$ 是独立的上下文词向量</strong>，其作用将会在4.2节讨论。在这个方程中，右侧部分是从语料库中提取的，$ F$ 可能依赖于一些尚未指定的参数。F的可能取值是非常多的，但是通过强制执行一些需求，我们可以选择一个唯一的选择。首先，我们希望$ F$ 编码在词向量空间中表示$ P_{ik}/P_{jk}$ 比率的信息。由于向量空间本质上是线性结构，最自然的方法就是使用向量差值。为了达到这个目的，我们可以将我们的考虑限制在只依赖于两个目标词的差值的函数F上，从而修改公式1为：</p>
<script type="math/tex; mode=display">
F(w_i - w_j, \tilde{w_k}) = \frac{P_{ik}}{P_{jk}} \tag{2}</script><p> &emsp;&emsp; 接下来,我们注意到公式2中函数$ F$ 的参数是是向量，而函数右边是标量。虽然$ F$ 可以被看作是一个复杂的函数，例如神经网络参数化的函数，但这样做会使我们试图捕捉的线性结构变得模糊。为了避免这个问题，我们可以先取参数的点积，即：</p>
<script type="math/tex; mode=display">
F((w_i - w_j)^T \tilde{w_k}) = \frac{P_{ik}}{P_{jk}} \tag{3}</script><p> &emsp;&emsp; 公式3使得$ F$ 不会采用一些不希望的方法来融合向量维度。接下来，我们发现，对于word-word共现矩阵来说，单词和上下文单词之间的区别是任意的，我们可以自由地交换这两个角色（即这个可以是单词，也可以是上下文单词）。这样做的话，我们不仅仅要满足在交换$ w$ 和$ \tilde{w}$ 后结果不变，而且交换$ X$ 和$ X^T$ 后结果也不变。但是，公式3并不满足这个性质，然而这种对称性，我们可以通过两个步骤来恢复。</p>
<p> &emsp;&emsp; 首先，我们需要函数$ F$ 是在$ (\mathbb{R},+)$ 和$ (\mathbb{R_{&gt;0}},\times)$ 的同态，例如：</p>
<script type="math/tex; mode=display">
F((w_i - w_j)^T \tilde{w_k}) = \frac{F(w_i^T \tilde{w_k})}{F(w_j^T \tilde{w_k})} \tag{4}</script><p> &emsp;&emsp; 在公式3中：</p>
<script type="math/tex; mode=display">
F(w_i^T\tilde{w_k}) = P_{ik} = \frac{X_{ik}}{X_i} \tag{5}</script><p> &emsp;&emsp; 之后，我们可以令$ F = \exp$ ，这样的话：</p>
<script type="math/tex; mode=display">
w_i^T \tilde{w_k} = \log(P_{ik}) = \log(X_{ik}) - \log(X_i) \tag{6}</script><p> &emsp;&emsp; 我们发现，如果公式6中没有$ \log(X_i)$ 这一项的话，它是满足对称性的。而这一项对$ k$ 是独立的，所以我们可以将其表示成偏移$ b_i$ ，最后，我们再添加一个偏移$ \tilde{b_k}$ ，这样就满足了对称性，即：</p>
<script type="math/tex; mode=display">
w_i^T \tilde{w_k} + b_i + \tilde{b_k} = \log(X_{ik}) \tag{7}</script><p> &emsp;&emsp; 公式7是公式1的极简化，但是它实际上是不明确的，因此对数函数在参数为0时是发散的。一个解决方法就是加上一个小的偏移，即$ \log(X_{ik}) \to \log(1+X_{ik})$ ，这不仅保持了$ X$ 的稀疏性，还解决了发散的问题。分解共现矩阵的对数的想法与LSA很相似，我们将使用得到的模型作为我们实验的baseline。该模型的一个主要缺点是，它对所有共现的情况都一视同仁，即使是那些很少发生或从不发生的情况。这种很少出现的共现是嘈杂的，而且比更频繁的共现所携带的信息更少——然而实体为0的情况占了X中数据的75-95%（具体数值与词汇量和语料库的大小有关）。</p>
<p> &emsp;&emsp; 我们提出了一个新的带权重的最小平方回归问题模型来解决这个问题，我们可以把公式7转换成最小平方问题，然后引入一个权重函数$ f(X_{ij})$ ，那么我们的损失函数如下：</p>
<script type="math/tex; mode=display">
J = \sum_{i,j=1}^V f(X_{ij})(w_i^T \tilde{w_j} + b_i + \tilde{b_j} - \log(X_{ij}) \tag{8})</script><p> &emsp;&emsp; 其中，$ V$ 为词汇表的大小，同时，权重函数应该具备以下的属性：</p>
<ol>
<li><strong>$ f(0) =0$ ，如果$ f$ 是一个连续函数的话，当$ x \to 0$ 的时候，他应该也趋于0，使得$ \lim_{x \to 0}f(x) \log^2 x$ 有解。</strong></li>
<li><strong>$ f(x)$ 应该是非递减的，这样，稀有的共现情况就不会给予过大的权重</strong></li>
<li><p><strong>当$ x$ 比较大时，$ f(x)$ 应该相对小一些，这样比较频繁的共现情况也就不会给予过大的权重</strong></p>
<p>&emsp;&emsp; 当然，有一大堆函数满足这些性质，但是，我们发现有一类函数效果非常好：</p>
<script type="math/tex; mode=display">
f(x)=
\begin{cases}
(x/x_{max})^{\alpha} & & if\ x<x_{max}\\
1 & & otherwise \\
\end{cases} \\
\tag{9}</script><p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/3.png?raw=true"  alt="3"></p>
<p>&emsp;&emsp; 在我们的所有实验中，我们采用$ x_{max} = 100$ ，我们发现$ \alpha = 3/4$ 的效果比$ \alpha=1$ 的效果要好</p>
</li>
</ol>
<h3 id="3-1-Relationship-to-Other-Models"><a href="#3-1-Relationship-to-Other-Models" class="headerlink" title="3.1 Relationship to Other Models"></a>3.1 Relationship to Other Models</h3><p> &emsp;&emsp; 因为所有的学习词向量的无监督的方法最终都是基于语料库的出现统计数据，这些模型存在着共性。然而，某些模型在这方面仍然有些不透明，特别是最近的基于窗口的方法，如skip-gram和ivLBL。因此，在本小节中，我们将展示这些模型如何与我们在公式8中定义的模型相关联。</p>
<p> &emsp;&emsp; skip-gram和ivLBL方法，利用模型输出$ Q_{ij}$ ，其表示单词$ j$ 出现在单词$ i$ 的上下文中的概率，具体来说，我们可以将$ Q_{ij}$ 定义为softmax：</p>
<script type="math/tex; mode=display">
Q_{ij} = \frac{exp(w_i^T\tilde{w_j})}{\sum_{k=1} ^V exp(w_i^T\tilde{w_k})} \tag{10}</script><p> &emsp;&emsp; 在他们在语料库中扫描上下文窗口时，他们会最大化这个log概率值，这一部分与我们的目的相关，其他的细节都无关。其隐藏的全局损失函数可以描述为：</p>
<script type="math/tex; mode=display">
J = -\sum_{i \in corpus \\ j\in context(i)} \log Q_{ij} \tag{11}</script><p> &emsp;&emsp; <strong>评估这个总和中的softmax的归一化因子的代价是昂贵的</strong>，为了进行有效的训练，skip-gram 和 ivLBL模型引入了$ Q_{ij}$ 的估计。然而，公式11中的总和，我们可以更加精确的进行评估，我们可以利用整体的语料库来构建损失函数，即：</p>
<script type="math/tex; mode=display">
J = -\sum_{i=1}^V \sum_{j=1}^V X_{ij} \log Q_{ij} \tag{12}</script><p> &emsp;&emsp; 我们知道，$ X_i = \sum_k X_{ik},P_{ij} = X_{ij}/X_i$ ，所以上式可以写为：</p>
<script type="math/tex; mode=display">
J = -\sum_{i=1}^V X_i \sum_{j=1}^V P_{ij} \log Q_{ij} = \sum_{i=1}^VX_i H(P_i,Q_i) \tag{13}</script><p> &emsp;&emsp; 其中，$ H(P_i,Q_i)$ 是分布$ P_i,Q_i$ 的交叉熵。作为一个带权重的交叉熵损失和，该目标与公式8的加权最小二乘目标有某种形式上的相似性。事实上，我们可以直接把公式13作为优化目标来进行在线的训练，这个目标可以被称之为“global skip-gram”模型。另一方面，公式13解决了大量的不良的属性问题。</p>
<p> &emsp;&emsp; 首先，交叉熵误差只是概率分布之间许多可能的距离度量之一，而且它有一个不好的属性，即长尾分布的建模常常很差，对不太可能发生的事件给予了太多的权重。此外，为了使得距离度量优解，我们需要对模型输出$ Q$ 进行归一化，但是<strong>公式10所示的归一化方式计算代价太大，为了解决这个问题，我们选择更换一个不需要归一化的距离度量方式。最自然的选择就是最小二乘目标，$ P,Q$ 的归一化因子也都被舍去</strong>：</p>
<script type="math/tex; mode=display">
\hat{J} = \sum_{i,j}X_i (\hat{P_{ij}} - \hat{Q_{ij}})^2 \tag{14}</script><p> &emsp;&emsp; 其中，$ \hat{P_{ij}} = X_{ij} , \hat{Q_{ij}} = \exp(w_i^T\tilde{w_j})$ 属于未归一化的分布。这又导致了另一个问题，那就是$ X_{ij}$ 经常会特别的大，这会使得优化步骤变得特别复杂。一个有效的补救方法是最小化的对数的平方误差，即：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{split}
\hat{J} &= \sum_{i,j}X_i (\log \hat{P_{ij}} - \log \hat{Q_{ij}})^2  \\
&=\sum_{i,j}X_i (w_i^T\tilde{w_j} - \log X_{ij})^2 \\
\end{split}
\end{equation}
\tag{15}</script><p> &emsp;&emsp; 最后，我们观察到，虽然在线训练方法预先规定了skip-gram和ivLBL模型固有的权重因子$ X_i$ ，但它并不能保证是最优的。事实上，Mikolov等人(2013a)观察到可以通过过滤数据来降低频繁词的权重因子的有效值来提高性能。考虑到这一点，我们引入了一个更一般的权重函数，我们也可以根据上下文单词自由地使用它。即：</p>
<script type="math/tex; mode=display">
\hat{J}=\sum_{i,j}f(X_i) (w_i^T\tilde{w_j} - \log X_{ij})^2 \tag{16}</script><p> &emsp;&emsp; 而该式子也等价于公式8</p>
<h3 id="3-2-Complexity-of-the-model"><a href="#3-2-Complexity-of-the-model" class="headerlink" title="3.2 Complexity of the model"></a>3.2 Complexity of the model</h3><p> &emsp;&emsp; 从公式8中，我们可以明确的了解到，模型的复杂度取决于共现矩阵$ X$ 中非零元素的数目，由于这个数目始终小于矩阵的总实体数目，因此模型的复杂度不会高于$ O(|V|^2)$ 。乍一看，这似乎是对基于窗口的方法的实质性改进，其屈居于语料库大小$ |C|$ ，但是一般词汇表中有几十万个单词，因此$ |V|^2$ 将会数千亿，这实际上比语料库要大得多，出于这个原因，基于矩阵$ X$ 的非零元素数目来决定一个更小的边界是比较重要的。</p>
<p> &emsp;&emsp; 为了对矩阵$ X$ 中非零元素的数目做出更准确的描述，对单词的共现分布做出一些假设是很有必要的。特别的，我们假设单词$ i$ 和单词$ j$ 的共现次数可以被建模为 该单词对频率秩$ r_{ij}$ 的幂律函数，即：</p>
<script type="math/tex; mode=display">
X_{ij} = \frac{k}{(r_{ij})^{\alpha}} \tag{17}</script><p> &emsp;&emsp; 语料库中的单词总数与共现矩阵$ X$ 的所有元素的总和成正比，即：</p>
<script type="math/tex; mode=display">
|C| \sim \sum_{ij}X_{ij} = \sum_{r=1}^{|X|}\frac{k}{r^{\alpha}} = kH_{|X|,\alpha} \tag{18}</script><p> &emsp;&emsp; 我们使用广义调和函数$ H_{n,m}$ 修改了最后的和函数。这个和的上限值为$ |X|$ ，是最大频率秩，与矩阵$ X$ 中非零元素的个数一致，该数也等于公式17中$ r$ 的最大值。因此，$ |H| = k^{1/\alpha}$ （没看懂怎么来的），因此，公式18可以描述为：</p>
<script type="math/tex; mode=display">
|C| \sim |X|^{\alpha} H_{|X|,\alpha} \tag{19}</script><blockquote>
<p>这之后的，我就看不懂了，卑微</p>
</blockquote>
<p> &emsp;&emsp; 我们感兴趣的是当两个数都很大时$ |X|$ 和$ |C|$ 是如何相关的，对于大的$ |H|$ 来说，我们可以自由地展开方程的右边。为此，我们使用广义调和数的展开(Apostol,  1976)：</p>
<script type="math/tex; mode=display">
H_{x,s} = \frac{x^{1-s}}{1-s} + \zeta(s) + O(x^{-s})\ \text{if}\ s>0,s\ne 1 \tag{20}</script><p> &emsp;&emsp; 因此：</p>
<script type="math/tex; mode=display">
|C| \sim \frac{|X|}{1-\alpha} + \zeta(\alpha)|X|^{\alpha} + O(1) \tag{21}</script><p> &emsp;&emsp; 其中，$ \zeta(s)$ 是黎曼ζ函数。当$ X$ 很大时，公式21中右侧的两项中只有一项是有关的，而这一项又依赖于$ \alpha$ 是否大于1，即：</p>
<script type="math/tex; mode=display">
|X|=
\begin{cases}
O(|C|) & & \text{if}\ \alpha<1\\
O(|C|^{1/\alpha}) & & \text{if}\ \alpha>1\\
\end{cases} \\
\tag{9}</script><p> &emsp;&emsp; 在对语料库研究之后，我们发现，当我们采用$ \alpha=1.25$ 时，我们采用公式17可以很好的建模$ X_{ij}$ ，在这种情况下，$ |X| = O(|C|^{0.8})$ ，所以，我们的模型的复杂度比最坏的情况$ O(V^2)$ 要好得多，事实上，它比基于窗口的在线方法(如$ O(|C|)$ )也要好一些。</p>
<h2 id="4、Experiments"><a href="#4、Experiments" class="headerlink" title="4、Experiments"></a>4、Experiments</h2><h3 id="4-1-Evaluation-methods"><a href="#4-1-Evaluation-methods" class="headerlink" title="4.1 Evaluation methods"></a>4.1 Evaluation methods</h3><p> &emsp;&emsp; 我们对Mikolov等人(2013a)的单词类比任务（word analogy task）、(Luong等人2013)中描述的各种单词相似度任务（word similarity tasks）以及命名实体辨识（NER）的CoNLL-2003共享基准数据集(Tjong Kim Sang和De Meulder, 2003)进行了实验。</p>
<h4 id="4-1-1-Word-analogies"><a href="#4-1-1-Word-analogies" class="headerlink" title="4.1.1 Word analogies"></a>4.1.1 Word analogies</h4><p> &emsp;&emsp; 单词类比任务由以下问题组成，“a is to b as c is to _?”数据集包含了19544个这样的问题，分为一个语义子集和一个语法子集。语义问题通常是关于人或地方的类比，比如“Athens is to Greece as Berlin is to _?”，句法问题通常是对动词时态或形容词形式的类比，比如“dance is to dancing as fly is to _?”.为了正确地回答这个问题，模型应该唯一地识别缺失的术语，只有精确的对应才算正确的匹配。我们需要通过余弦相似度找到最接近接近$ w_b - w_a + w_c$ 的词向量$ w_d$ 来找到单词$ d$ ，来回答问题，“a is to b as c is to _?”</p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/1.jpg?raw=true"  alt="1"></p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/4.png?raw=true"  alt="4"></p>
<h4 id="4-1-2-Word-similarity"><a href="#4-1-2-Word-similarity" class="headerlink" title="4.1.2 Word similarity"></a>4.1.2 Word similarity</h4><p> &emsp;&emsp; 虽然类比任务是我们的主要关注点，因为它测试感兴趣的向量空间子结构，但我们也在表3中的各种单词相似性任务上评估我们的模型。其中包括WordSim-353  (Finkelstein et al.， 2001)、MC (Miller and Charles, 1991)、RG (Rubenstein and  Goodenough, 1965)、SCWS (Huang et al.， 2012)和RW (Luong et al.， 2013)。</p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/5.jpg?raw=true"  alt="5"></p>
<h4 id="4-1-3-Named-entity-recognition"><a href="#4-1-3-Named-entity-recognition" class="headerlink" title="4.1.3 Named entity recognition"></a>4.1.3 Named entity recognition</h4><p> &emsp;&emsp; CoNLL-2003英文NER基准数据集是Reuters  newswire文章中的文档集合，注释有四种实体类型:person、location、organization和miscellaneous。我们在三个数据集上对CoNLL-03训练数据进行测试训练模型:1)CoNLL-03测试数据，2)ACE Phase  2(2001-02)和ACE-2003数据，3)MUC7正式运行测试集。我们采用BIO2标注标准，以及(Wang and Manning,  2013)中所述的所有预处理步骤。我们使用了斯坦福NER模型标准分布所附带的一套全面的离散特征(Finkel et al.，  2005)。总共为CoNLL-2003训练数据集生成了437,905个离散特征。此外，为五个单词上下文中的每个单词添加50维向量，并用作连续特征。将这些特征作为输入，我们训练了条件随机场(CRF)，其设置与(Wang  and Manning, 2013)的CRFjoinmodel完全相同。</p>
<h3 id="4-2-Corpora-and-training-details"><a href="#4-2-Corpora-and-training-details" class="headerlink" title="4.2 Corpora and training details"></a>4.2 Corpora and training details</h3><p> &emsp;&emsp; 我们在5个不同大小的语料库上训练我们的模型：2010年由10亿token组成的Wikipedia；2014年由16亿token组成的Wikipedia；由43亿token组成的Gigaword  5；Gigaword 5和Wikipedia 2014的结合，共有60亿token以及具有420亿token来自普通爬虫的web数据。我们使用Stanford分词器对每个语料库进行分词和小写化，构建一个包含40万个最常见单词的词汇表，然后构建一个共现计数矩阵$ X$ 。在构造$ X$ 时，我们必须选择上下文窗口应该有多大，以及是否区分左上下文和右上下文。我们将在下面探讨这些选择的影响。在所有的情况下，我们都使用一个递减的加权函数，这样相距d个单词的单词对占总数的1/d。这是一种解释这样一个事实的方法，即非常远的词对应该包含较少的关于词与其他词之间关系的信息。</p>
<p> &emsp;&emsp; 对于所有的实验，<strong>我们设置$ X_{max} = 100, \alpha = 3/4$ ，使用AdaGrad来训练模型，随机的从矩阵$ X$ 中采样非零元素，同时初始化学习率为0.05。如果词向量维度小于300，则迭代50次，否则迭代100次</strong>（有关收敛速度的更多细节，请参见4.6节）。除非另有说明，我们使用的上下文中左边十个词，右边十个词。</p>
<p> &emsp;&emsp; <strong>该模型生成两组词向量$ W$ 和$ \tilde{W}$ 。当$ X$ 是对称的时$ W$ 和$ \tilde{W}$ 是等价的，</strong>不同的只是由于他们的随机初始化而造成的不同，所以本质上两者是等价的，都可以作为最终的结果。另一方面，有证据表明，对于某些类型的神经网络，训练多个网络实例，然后将结果结合起来，有助于减少过拟合和噪声，总体上提高结果(Ciresan  et al.， 2012)。因此，我<strong>们最后会选择$ W+\tilde{W}$ 作为我们的词向量，这样做通常会略微提高性能</strong>，而语义类比任务的增幅最大。</p>
<p> &emsp;&emsp; 我们比较了各种最新模型的结果，以及我们自己使用word2vec工具和使用SVDs的几个baseline生成的结果。使用word2vec，我们在60亿个token语料库(Wikipedia  2014 + Gigaword  5)上训练了skip-gram(SG†)和(CBOW†)模型，其中包含40万个最常见的词汇，上下文窗口大小为10。我们使用了10个负样本，我们在4.6节中表明这是一个很好的选择。</p>
<p> &emsp;&emsp; 对于SVD baseline，我们生成一个截断的矩阵$ X_{trunc}$ ，它保留了每个单词出现频率的信息，只包含前10000个最常见的单词。这个步骤是许多基于矩阵因子分解的方法的典型步骤，因为额外的列可能造成不成比例的零条目数，并且这些方法在计算上很昂贵。</p>
<p> &emsp;&emsp; 该矩阵的奇异向量构成“SVD”的baseline。我们还计算了两个相关的baseline：“SVD- S”（其中SVD取$ \sqrt{Xtrunc}$ ），“SVD-  L”（其中SVD取$ \log(1+X_{trunc})$ ）。这两种方法都有助于压缩$ X$中较大范围的值</p>
<h3 id="4-3-Results"><a href="#4-3-Results" class="headerlink" title="4.3 Results"></a>4.3 Results</h3><p> &emsp;&emsp; 我们在表2中给出了单词类比任务的结果。GloVe模型的性能明显优于其他baseline，通常具有较小的向量大小和较小的语料库。我们使用word2vec工具得到的结果比以前发布的大多数结果要好一些。这是由许多因素造成的，包括我们选择使用负抽样(它通常比分级的softmax更好)、负抽样的数量和语料库的选择。</p>
<p> &emsp;&emsp; 我们证明，该模型可以很容易地在420亿个token语料库上进行训练，并有显著的性能提升。我们注意到，增加语料库大小并不能保证其他模型的性能得到改善，这一点可以从更大语料库上的SVD-L模型的性能下降中看出。这个基本的奇异值分解模型并不能很好地适应大型语料库，这进一步证明了模型中所提出的加权方案的必要性。</p>
<p> &emsp;&emsp; 表3显示了五个不同单词相似度数据集的结果。首先对词汇表中的每个特征进行归一化，然后计算余弦相似度，从而得到词向量的相似度评分。我们计算这一分数与人类判断之间的斯皮尔曼等级相关系数。CBOW∗表示word2vec网站上可用的向量，它使用新闻数据中100B个单词上的单词和短语向量进行训练。使用不到一半大小的语料库时，GloVe的性能优于它。</p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/5.jpg?raw=true"  alt="5"></p>
<p> &emsp;&emsp; 表4显示了使用基于CRF模型的NER任务的结果。当验证集在25次迭代中没有取得任何改进时，L-BFGS训练终止。否则，所有配置都与Wang和Manning(2013)使用的相同。标记为离散的模型是使用一套完整的离散特征的基线，这些特征来自斯坦福NER模型的标准分布，但是没有词向量特征。除了前面讨论的HPCA和SVD模型外，我们还将其与Huang et al. (2012) (HSMN)和Collobert and Weston (2008) (CW)的模型进行了比较。我们使用word2vec工具训练CBOW模型。GloVe模型在所有评估指标上都优于其他所有方法，除了CoNLL测试集，HPCA方法在CoNLL测试集上做得稍好一些。我们得出的结论是，GloVe载体在下游的自然规划任务中是有用的。</p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/6.jpg?raw=true"  alt="6"></p>
<h3 id="4-4-Model-Analysis-Vector-Length-and-Context-Size"><a href="#4-4-Model-Analysis-Vector-Length-and-Context-Size" class="headerlink" title="4.4 Model Analysis: Vector Length and Context Size"></a>4.4 Model Analysis: Vector Length and Context Size</h3><p> &emsp;&emsp; 在图2中，我们展示了改变词向量维度长度和上下文窗口大小的实验结果。扩展到目标词的左右两边的上下文窗口称为对称的，只扩展到左边的上下文窗口称为不对称的。在(a)中，我们观察到大于200维的向量的收益递减。在(b)和(c)中，我们研究了改变窗口大小对对称和非对称上下文窗口的影响。对于较小且不对称的上下文窗口，在句法子任务上的性能更好，这与句法信息大多来自于直接上下文、对词序的依赖性强的直觉是一致的。另一方面，语义信息更多地是非本地的，而且更多的语义信息是通过更大的窗口大小捕获的。</p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/4.png?raw=true"  alt="4"></p>
<h3 id="4-5-Model-Analysis-Corpus-Size"><a href="#4-5-Model-Analysis-Corpus-Size" class="headerlink" title="4.5 Model Analysis: Corpus Size"></a>4.5 Model Analysis: Corpus Size</h3><p> &emsp;&emsp; 在图3中，我们展示了在不同语料库上训练的300维向量进行单词类比任务的性能。在句法子任务上，随着语料库大小的增加，表现呈单调递增。这是可以预料的，因为较大的语料库通常产生更好的统计数据。有趣的是，同样的趋势在语义子任务中并不成立，在较小的Wikipedia语料库中训练的模型比在较大的Gigaword语料库中训练的模型表现更好。这可能是由于类比数据集中有大量基于城市和国家的类比，而且维基百科的条目会更新以吸收新知识，而Gigaword只是一个固定的新闻储存库，里面有过时的、甚至可能是错误的信息。</p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/7.png?raw=true"  alt="7"></p>
<h3 id="4-6-Model-Analysis-Run-time"><a href="#4-6-Model-Analysis-Run-time" class="headerlink" title="4.6 Model Analysis: Run-time"></a>4.6 Model Analysis: Run-time</h3><p> &emsp;&emsp; 总运行时间在填充共现矩阵$ X$ 和训练模型之间进行分割。前者取决于许多因素,包括窗口大小,词汇量的大小,和语料库的大小。虽然我们没有这样做，但这一步可以很容易地在多台机器上并行化(参见Lebret和Collobert(2014)的一些基准测试)。使用双2.1GHz  Intel Xeon  E5-2658机器的单个线程，用10个单词对称上下文窗口、40万个单词词汇表和60亿个token语料填充$ X$ 大约需要85分钟。给定$ X$ ，用于训练模型的时间取决于向量的大小和迭代次数。对于具有上述设置的300维向量(并使用上述机器的所有32个核心)，一次迭代需要14分钟。学习曲线如图4所示。</p>
<h3 id="4-7-Model-Analysis-Comparison-with-word2vec"><a href="#4-7-Model-Analysis-Comparison-with-word2vec" class="headerlink" title="4.7 Model Analysis: Comparison with word2vec"></a>4.7 Model Analysis: Comparison with word2vec</h3><p> &emsp;&emsp; 由于存在许多对性能有很大影响的参数，GloVe与word2vec的严格定量比较变得很复杂。我们通过将磁向量长度、上下文窗口大小、语料库和词汇表大小设置为前面小节中提到的配置来控制我们在4.4和4.5节中确定的主要变量来源。</p>
<p> &emsp;&emsp; 剩下的最重要的变量是训练时间。对于GloVe，相关参数为训练迭代次数。对于word2vec，明显的选择是训练epoch的数量。不幸的是，代码目前只设计了一个单一的迭代：它指定了一个特定于单个数据传递的学习计划，使得对多个传递的修改成为一个非琐碎的任务。另一种选择是改变负样本的数量。增加负样本有效地增加了模型看到的训练词的数量，因此在某些方面它类似于额外的epoch。</p>
<p> &emsp;&emsp; 我们将任何未指定的参数设置为默认值，假设它们接近于最佳值，尽管我们承认这种简化应该简化为更彻底的分析。</p>
<p> &emsp;&emsp; 在图4中，我们将模拟任务的总体性能作为训练时间的函数绘制出来。底部的两个x轴表示GloV e和word2vec的负样本对应的训练迭代次数。我们注意到，如果负样本的数量增加到10个以上，word2vec的性能实际上会下降。这大概是因为负抽样法不能很好地近似目标概率分布</p>
<p> &emsp;&emsp; 对于相同的语料库、词汇表、窗口大小和训练时间，GloVe始终优于word2vec。它能更快地得到更好的结果，也能在不考虑速度的情况下得到最好的结果。</p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/8.png?raw=true"  alt="8"></p>
<h2 id="5、Conclusion"><a href="#5、Conclusion" class="headerlink" title="5、Conclusion"></a>5、Conclusion</h2><p> &emsp;&emsp; 最近，相当多的注意力集中在这样一个问题上：词向量是从基于计数的方法中获得比较好，还是从基于预测的方法中获得比较好。目前，基于预测的模型获得了大量支持;例如，Baroni等人(2014)认为，这些模型在一系列任务中表现得更好。在本研究中，我们认为这两类方法在基本层面上没有显著差异，因为它们都探究了语料库的潜在共现统计，但基于计数的方法捕获全局统计的效率可能是有利的。我们构建了一个模型，利用计数数据的这种主要好处，同时捕获最近基于对数双线性预测的方法(如word2vec)中普遍存在的有意义的线性子结构。该模型在词语类比、词语相似度和命名实体识别任务方面都优于其他模型，为词语表示的无监督学习提供了一种新的全局对数双线性回归模型</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">白丁</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://baidinghub.github.io/2020/09/01/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/">http://baidinghub.github.io/2020/09/01/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://baidinghub.github.io" target="_blank">BaiDing's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a><a class="post-meta__tags" href="/tags/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">NLP基础知识</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDyIdOn/M/aXcGQOiSDVMqvN2gxDdiESHUfFuB2YMy48fvNN9SZOQUbVlGF4Pk6nDXIAir+br/EWuEnNLtgOCYMo/BTxl29gqS/QGHPiDaIQedzmLcuRZpfDuGit61N/b9pyktpZLagBgbl5Ox9mAgWQxXyhxYB092gyOXqrBULBeZUYQ+H7Eupha10QTQghHv4nLk+oYWo2UXEiijQpE3qMXT32G8v8k0KbRdd1hIFPyNEx6eZ6Buc2ZdbMtoutdGjvdnw5B1+dxgl1egESPChzcwCMxt3NW/3faQ5lsjRhQD4fRU+Ua/aqXe+0xg2+xr0BTjNr/JZIAaNiLuo71lH 1564026260@qq.com" async="async"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/wechat.png?raw=true" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/alipay.jpg?raw=true" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/09/02/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89FastText/"><img class="prev_cover lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89FastText/cover.png?raw=true" onerror="onerror=null;src='https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/404.jpg?raw=true'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">NLP词向量篇（三）FastText</div></div></a></div><div class="next-post pull_right"><a href="/2020/09/01/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89Word2Vec/"><img class="next_cover lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89Word2Vec/cover.png?raw=true" onerror="onerror=null;src='https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/404.jpg?raw=true'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">NLP词向量篇（一）Word2Vec</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/09/11/NLP特征提取器篇（一）RNN/" title="NLP特征提取器篇（一）RNN"><img class="relatedPosts_cover lazyload"data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%99%A8%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89RNN/cover.png?raw=true"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-11</div><div class="relatedPosts_title">NLP特征提取器篇（一）RNN</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/12/NLP特征提取器篇（三）Transformer/" title="NLP特征提取器篇（三）Transformer"><img class="relatedPosts_cover lazyload"data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%99%A8%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89Transformer/cover.png?raw=true"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-12</div><div class="relatedPosts_title">NLP特征提取器篇（三）Transformer</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/22/NLP词向量篇（七）RoBERTa/" title="NLP词向量篇（七）RoBERTa"><img class="relatedPosts_cover lazyload"data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%83%EF%BC%89RoBERTa/cover.png?raw=true"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-22</div><div class="relatedPosts_title">NLP词向量篇（七）RoBERTa</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/11/NLP特征提取器篇（二）LSTM/" title="NLP特征提取器篇（二）LSTM"><img class="relatedPosts_cover lazyload"data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%99%A8%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89LSTM/cover.png?raw=true"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-11</div><div class="relatedPosts_title">NLP特征提取器篇（二）LSTM</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/21/NLP词向量篇（五）GPT-1/" title="NLP词向量篇（五）GPT-1"><img class="relatedPosts_cover lazyload"data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/cover.png?raw=true"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-21</div><div class="relatedPosts_title">NLP词向量篇（五）GPT-1</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/02/NLP词向量篇（三）FastText/" title="NLP词向量篇（三）FastText"><img class="relatedPosts_cover lazyload"data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89FastText/cover.png?raw=true"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-02</div><div class="relatedPosts_title">NLP词向量篇（三）FastText</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'd3948be001a91411dfd9',
  clientSecret: 'ebddf2a2a5a039922fb373a8a8c0efcc439bf6ca',
  repo: 'BaiDingHub.github.io',
  owner: 'BaiDingHub',
  admin: ['BaiDingHub'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" style="background-image: url(https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89Glove/cover.png?raw=true)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 白丁</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://jerryc.me/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js" ></script><script src="/js/utils.js" ></script><script src="/js/main.js" ></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/search/algolia.js"></script></body></html>