<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>NLP词向量篇（五）GPT-1 | BaiDing's blog</title><meta name="description" content="NLP词向量篇（五）GPT-1"><meta name="keywords" content="深度学习,NLP基础知识"><meta name="author" content="白丁"><meta name="copyright" content="白丁"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://raw.githubusercontent.com/BaiDingHub/Blog_images/master/BlogSource/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="crossorigin"/><link rel="preconnect" href="http://ta.qq.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="x-1ef6P_miWkq-RJn_fmjd3KYumrXANNXYzK1myaLf0"/><meta name="baidu-site-verification" content="guD6l44Chk"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="NLP词向量篇（五）GPT-1"><meta name="twitter:description" content="NLP词向量篇（五）GPT-1"><meta name="twitter:image" content="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/cover.png?raw=true"><meta property="og:type" content="article"><meta property="og:title" content="NLP词向量篇（五）GPT-1"><meta property="og:url" content="http://baidinghub.github.io/2020/09/21/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/"><meta property="og:site_name" content="BaiDing's blog"><meta property="og:description" content="NLP词向量篇（五）GPT-1"><meta property="og:image" content="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/cover.png?raw=true"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://baidinghub.github.io/2020/09/21/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/"><link rel="prev" title="NLP词向量篇（六）BERT" href="http://baidinghub.github.io/2020/09/22/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89BERT/"><link rel="next" title="NLP词向量篇（四）ELMo" href="http://baidinghub.github.io/2020/09/21/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89ELMo/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-162698439-1', 'auto');
ga('send', 'pageview');
</script><script src="https://tajs.qq.com/stats?sId=66540586" charset="UTF-8"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"4JGH9NW4XG","apiKey":"41cdb6d9ec4d21196956524e9c985b36","indexName":"baiding","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/avatar.png?raw=true" onerror="onerror=null;src='https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/friend_404.gif?raw=true'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">94</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">60</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 存档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于作者</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Improving-Language-Understanding-by-Generative-Pre-Training"><span class="toc-text">Improving Language Understanding by Generative Pre-Training</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内容分析"><span class="toc-text">内容分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1）pre-training阶段"><span class="toc-text">1）pre-training阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2）fine-tuning阶段"><span class="toc-text">2）fine-tuning阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3）下游任务的输入转换"><span class="toc-text">3）下游任务的输入转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4）-GPT的效果"><span class="toc-text">4） GPT的效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1、Introduction"><span class="toc-text">1、Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、Related-Work"><span class="toc-text">2、Related Work</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Semi-supervised-learning-for-NLP"><span class="toc-text">2.1 Semi-supervised learning for NLP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Unsupervised-pre-training"><span class="toc-text">2.2 Unsupervised pre-training</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Auxiliary-training-objectives"><span class="toc-text">2.3 Auxiliary training objectives</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、Framework"><span class="toc-text">3、Framework</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Unsupervised-pre-training"><span class="toc-text">3.1 Unsupervised pre-training</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Supervised-fine-tuning"><span class="toc-text">3.2 Supervised fine-tuning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Task-specific-input-transformations"><span class="toc-text">3.3 Task-specific input transformations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、Experiments"><span class="toc-text">4、Experiments</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Setup"><span class="toc-text">4.1 Setup</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-Unsupervised-pre-training"><span class="toc-text">4.1.1 Unsupervised pre-training</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-Model-specifications"><span class="toc-text">4.1.2 Model specifications</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-Fine-tuning-details"><span class="toc-text">4.1.3 Fine-tuning details</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Supervised-fine-tuning"><span class="toc-text">4.2 Supervised fine-tuning</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-Natural-Language-Inference"><span class="toc-text">4.2.1 Natural Language Inference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-Question-answering-and-commonsense-reasoning"><span class="toc-text">4.2.2 Question answering and commonsense reasoning</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-Semantic-Similarity"><span class="toc-text">4.2.3 Semantic Similarity</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、Analysis"><span class="toc-text">5、Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Impact-of-number-of-layers-transferred"><span class="toc-text">5.1 Impact of number of layers transferred</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Zero-shot-Behaviors"><span class="toc-text">5.2 Zero-shot Behaviors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Ablation-studies"><span class="toc-text">5.3 Ablation studies</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、Conclusion"><span class="toc-text">6、Conclusion</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/cover.png?raw=true)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">BaiDing's blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 存档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于作者</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">NLP词向量篇（五）GPT-1</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-09-21 15:20:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-09-21</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-12-02 11:11:09"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-12-02</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">NLP基础知识</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">7.2k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 23 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/09/21/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><meta name="referrer" content="no-referrer"/>



<h1 id="Improving-Language-Understanding-by-Generative-Pre-Training"><a href="#Improving-Language-Understanding-by-Generative-Pre-Training" class="headerlink" title="Improving Language Understanding by Generative Pre-Training"></a>Improving Language Understanding by Generative Pre-Training</h1><blockquote>
<p>时间：2018年</p>
<p>关键词：NLP, Word Embedding</p>
<p>论文位置：<a href="https://www.cs.ubc.ca/~amuham01/LING530/papers/radford2018improving.pdf" target="_blank" rel="noopener">https://www.cs.ubc.ca/~amuham01/LING530/papers/radford2018improving.pdf</a></p>
<p>引用：Radford A, Narasimhan K, Salimans T, et al. Improving language understanding by generative pre-training[J]. 2018.</p>
</blockquote>
<p><strong>摘要：</strong>自然语言理解包括各种各样的任务，如文本蕴涵、问题回答、语义相似度评估和文档分类。虽然<strong>大量的未标记文本语料库是丰富的，但用于学习这些特定任务的标记数据是稀缺的，这使得区分训练的模型很难充分执行</strong>。我们证明，在这些任务中，<strong>可以通过生成语言模型对不同的未标记文本语料库进行预训练，然后对每个特定任务进行有区别的微调来实现</strong>。与之前的方法相比，<strong>我们在微调期间使用任务感知的输入转换，从而在对模型体系结构进行最小更改的同时实现有效的迁移</strong>。我们在自然语言理解的一系列baseline测试中证明了我们的方法的有效性。我们的模型（在未知下游任务时）比那些使用为每个任务专门设计的架构的经过区别训练的模型表现更好，在研究的12个任务中有9个任务的SOTA得到了显著改善。例如，我们在常识推理(故事完形填空测试)上取得了8.9%的绝对进步，在回答问题(种族)上取得了5.7%的绝对进步，在文本蕴涵(多项)上取得了1.5%的绝对进步。</p>
<p><strong>索引</strong>- 自然语言处理，动态词向量</p>
<h2 id="内容分析"><a href="#内容分析" class="headerlink" title="内容分析"></a>内容分析</h2><p> &emsp;&emsp; GPT可以说是ELMo的进化版本，其与ELMo的不同有：</p>
<ul>
<li>使用了<strong>特征提取能力更强的Transformer</strong>来进行特征提取</li>
<li>不同的NLP任务的输入是不一样的，比如文本相似性任务是给两个句子，而文本分类任务只给一个句子。<strong>GPT将不同任务的输入进行了转换，转换成了同一类型的输入</strong>。这样避免了我们为每一种NLP任务设计不同的架构</li>
<li><p><strong>添加了辅助目标函数来辅助fine-tuning的过程</strong></p>
<p>&emsp;&emsp; GPT主要干了三件事</p>
</li>
</ul>
<ol>
<li>利用Transformer设计一个representation表示模型，使得每个输入的token都能够得到一个比较好的representation，之后在一个规模比较大的训练集上对其进行预训练，这个数据集可能包含有多种不同的任务，但都是非监督任务。</li>
<li>Fine-tunning，即在一个下游任务（监督任务）中，加入预训练的模型，进行fine-tunning来拟合这个下游任务。到这，也就是GPT模型的整个过程就完成了，下面对其进行具体分析。</li>
<li>对不同的下游任务进行了统一化，即将不同类型的输入转换成同一类型的输入，大大简化了架构设计这一步骤。</li>
</ol>
<h3 id="1）pre-training阶段"><a href="#1）pre-training阶段" class="headerlink" title="1）pre-training阶段"></a>1）pre-training阶段</h3><p> &emsp;&emsp; 在预训练阶段，给定语料，$\ \mathcal{U} = {u_1,…,u_n}$ ，我们的目标是根据某个词的上下文预测这个词，即目标函数为：</p>
<script type="math/tex; mode=display">
L_1(\mathcal{U}) = \sum_i \log P(u_1|u_{i-k},...,u_{i-1};\Theta) \tag{1}</script><p> &emsp;&emsp; 其中$\ k$ 表示上下文窗口的大小， 我们使用参数为$\ \Theta$ 的神经网络建模条件概率$\ P$ ，我们使用梯度下降来训练这些参数。</p>
<p> &emsp;&emsp; 作者<strong>使用了多层Transformer的decoder层</strong>来建模$\ P$ 。对上下文采取了multi-head attention、self-attention、mask操作，之后使用position-wise的前馈层来生成目标token输出的分布，即：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{split}
h_0 &= UW_e + W_p\\
h_l &= \text{transformer_block}(h_{l-1}) \ \forall i \in [1,n]\\ 
P(u) &= \text{softmax}(h_n W_e^T)
\end{split}
\end{equation}
\tag{2}</script><p> &emsp;&emsp; 其中，$\ U = (u<em>{i-k},…,u</em>{i-1})$ ，是token的上下文向量，$\ n$ 使transformer层的数量，$\ W_e$ 是词向量矩阵，$\ W_p$ 是positon embedding矩阵。</p>
<p> &emsp;&emsp; 可以看到，在这个模型中，<strong>使用了Transformer的mask操作，也就意味着GPT使用的是单向Transformer，这是GPT的限制，在Bert中对这个问题进行了改进。</strong></p>
<h3 id="2）fine-tuning阶段"><a href="#2）fine-tuning阶段" class="headerlink" title="2）fine-tuning阶段"></a>2）fine-tuning阶段</h3><p> &emsp;&emsp; 上面训练完模型后，我们就把预训练的模型以及参数融入到下游任务中。对于某个下游任务，设其数据集$\ \mathcal{C}$ （带标签），某个输入的token为$\ (x^1,…,x^m)$ ， 对应的标签为$\ y$ 。将该输入送入我们的预训练模型中得到Transformer的输出$\ h_l^m$ 。然后将其送入到一个附加线性输出层中，该层的参数为$\ W_y$ ，来预测$\ y$ ：</p>
<script type="math/tex; mode=display">
P(y|x^1,...,x^m) = \text{softmax}(h_l^m W_y) \tag{3}</script><p> &emsp;&emsp; 那么，在该任务中的目标函数就是最大化下面的目标函数：</p>
<script type="math/tex; mode=display">
L_2(\mathcal{C}) = \sum_{(x,y)} \log P(y|x^1,...,x^m) \tag{4}</script><p> &emsp;&emsp; 另外，我们发现<strong>将语言模型的目标函数作为一个辅助目标函数来fine-tunning，是有帮助的，可以提升监督模型的泛化性并加速收敛。</strong>所以，我们的优化函数变成了：</p>
<script type="math/tex; mode=display">
L_3(\mathcal{C}) = L_2(\mathcal{C}) + \lambda * L_1(\mathcal{C}) \tag{5}</script><p> &emsp;&emsp; 总的来说，在fine-tunning期间，我们唯一需要调整的参数就是$\ W_y$ 以及分隔符$\ $$ 的词向量（见3.3节）。</p>
<h3 id="3）下游任务的输入转换"><a href="#3）下游任务的输入转换" class="headerlink" title="3）下游任务的输入转换"></a>3）下游任务的输入转换</h3><p> &emsp;&emsp; 对于某些任务，如文本分类，我们可以如上所述直接fine-tunning我们的模型。某些其他任务，如问题回答或文本蕴涵，具有结构化输入，如有序句子对，或文档、问题和答案的三元组。由<strong>于我们的预训练模型是在连续的文本序列上训练的，因此需要进行一些修改才能将其应用到这些任务中</strong>。我们使用 traversal-style的方法[52]，其中我们将结构化的输入转换为一个有序的序列，以便我们预先训练过的模型可以处理<strong>。这些输入转换允许我们避免跨任务对架构进行大量更改。</strong>我们在下面提供了这些输入转换的简要描述，图1提供了一个可视化的说明。所有的转换都包括添加随机初始化的开始和结束标记$\ (<s>,<e>)$。</p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/1.png?raw=true"  alt="1"></p>
<p><strong>Textual entailment</strong></p>
<p> &emsp;&emsp; 对于蕴含任务来说，我们把premise $\ p$ 和hypothesis $\ h$ 合起来，成为一个token句子，并使用分隔符token$\ $ $ 来分割。</p>
<p><strong>Similarity</strong></p>
<p> &emsp;&emsp; 对于相似性任务来说，一组输入中的两个句子是没有固定的先后顺序的。为了反映这一点，我们修改输入序列，使其包含两种可能的句子顺序(中间有一个分隔符)，并分别处理它们以生成两个序列表示$\ h_l^m$ ，这两个表示在输入到线性输出层之前按元素添加。</p>
<p><strong>Question Answering and Commonsense Reasoning</strong></p>
<p> &emsp;&emsp; 对于这些任务来说，给定一个语境文档$\ z$ ，一个问题$\ q$ ，一组可能的答案$\ {a_k}$ 。我们会把语境文档和问题与每一个可能的答案连起来，并在中间添加一个分隔符，如：$\ [z；q;$;a_k]$ 。每一个这样的句子都会被我们的模型单独的处理，然后通过softmax层进行规范化，产生一个可能答案的输出分布。</p>
<h3 id="4）-GPT的效果"><a href="#4）-GPT的效果" class="headerlink" title="4） GPT的效果"></a>4） GPT的效果</h3><p> &emsp;&emsp; GPT在12个任务中的9个都达到了SOTA的水平。看第四节</p>
<h2 id="1、Introduction"><a href="#1、Introduction" class="headerlink" title="1、Introduction"></a>1、Introduction</h2><p> &emsp;&emsp; 有效地从原始文本中学习的能力对于减轻自然语言处理(NLP)中对监督学习的依赖至关重要。大多数深度学习方法需要大量手工标记的数据，这限制了它们在许多缺乏注释资源的领域中的适用性[61]。在这些情况下，能够从未标记数据中利用语言信息的模型为收集更多注释提供了一种有价值的替代方案，后者可能耗时且昂贵。此外，即使在相当大的监督是可用的情况下，用无监督的方式学习良好的representation可以提供一个显著的性能提升。到目前为止，最令人信服的证据是广泛使用预先训练过的词向量来提高一系列NLP任务的表现[8,11,26,45]。</p>
<p> &emsp;&emsp; 然而，<strong>从未标记的文本中利用不仅仅是word级别的信息是有挑战性的，主要有两个原因</strong>。首先，<strong>还不清楚在学习对迁移有用的文本representation时，哪种类型的优化目标是最有效的</strong>。最近的研究着眼于各种目标，如语言建模[44]、机器翻译[38]和语篇连贯[22]，每种方法在不同任务上都优于其他方法。第二，<strong>对于将学习到的representation转移到目标任务的最有效的方式没有共识</strong>。现有的技术包括对模型体系结构进行任务特定变更的组合[44,44]，使用复杂的学习方案[21]和添加辅助学习目标[50]。这些不确定性使得开发有效的语言处理半监督学习方法变得困难。</p>
<p> &emsp;&emsp; 在本文中，我们探索了一种语言理解任务的半监督方法，<strong>使用无监督任务预训练和监督任务微调的组合</strong>。<strong>我们的目标是学习一种通用的表示法，这种表示法可以在不加调整的情况下，适应广泛的任务</strong>。我们假设可以访问大量未标记文本的语料库和一些带有人工注释的训练示例(目标任务)的数据集。我们的setup不要求这些目标任务与未标记的语料库在同一个域中。<strong>我们采用两阶段的训练步骤。首先，我们对未标记数据使用语言建模目标来学习神经网络模型的初始参数。随后，我们使用相应的监督目标将这些参数适应于目标任务。</strong></p>
<p> &emsp;&emsp; 对于我们的模型架构，我们<strong>使用了Transformer</strong>[62]，它已经被证明可以在各种任务上出色地执行，如机器翻译[62]、文档生成[34]和语法解析[29]。与循环网络等替代方案相比，<strong>这种模型选择为我们提供了一种更结构化的记忆，用于处理文本中的长期依赖关系，从而在不同任务中实现了稳健的传输性能</strong>。<strong>在迁移过程中，我们利用从traversal-style方法[52]派生出来的的特定于任务的输入调整，它将结构化文本输入处理为单个连续的token序列。正如我们在实验中所演示的，这些调整使我们能够在对预训练模型的架构进行最小更改的情况下有效地进行微调</strong></p>
<p> &emsp;&emsp; 我们在四种类型的语言理解任务上评估我们的方法——自然语言推理、问题回答、语义相似度和文本分类。我们的模型（在未知下游任务时）比那些为每个任务专门设计架构的经过区别训练的模型表现更好，在研究的12个任务中，有9个任务的技术水平得到了显著提高。例如，我们在常识推理(Stories Cloze Test)[40]上取得了8.9%的绝对进步，在回答问题(RACE)[30]上取得了5.7%的绝对进步，在文本蕴涵(MultiNLI)[66]上取得了1.5%的绝对进步，在最近引入的GLUE多任务基准测试[64]上取得了5.5%的绝对进步。我们还分析了预训练模型在四种不同环境下的zero-shot行为，证明它获得了对下游任务有用的语言知识。</p>
<h2 id="2、Related-Work"><a href="#2、Related-Work" class="headerlink" title="2、Related Work"></a>2、Related Work</h2><h3 id="2-1-Semi-supervised-learning-for-NLP"><a href="#2-1-Semi-supervised-learning-for-NLP" class="headerlink" title="2.1 Semi-supervised learning for NLP"></a>2.1 Semi-supervised learning for NLP</h3><p> &emsp;&emsp; 我们的工作基本上属于自然语言的半监督学习范畴。这种范式引起了人们的极大兴趣，应用于诸如序列标记[24,33,57]或文本分类[41,70]等任务。<strong>最早的方法使用未标记的数据来计算word级或phrase级的统计，然后将其作为特征用于监督模型[33]中</strong>。在过去的几年里，研究人员已经证明了使用<strong>词向量</strong>的好处[11,39,42]，<strong>它是在未标记的语料库上训练的，可以提高在各种任务上的表现[8,11,26,45]</strong>。然而，<strong>这些方法主要传递word级的信息，而我们的目标是捕获更高级别的语义。</strong></p>
<p> &emsp;&emsp; 最近的方法已经研究了学习和利用更多的词汇水平的语义从未标记的数据。phrase级或sentence级词向量可以使用未标记语料库进行训练，它们被用于将文本编码为适合各种目标任务的向量表示[28,32,1,36,22,12,56,31]。</p>
<h3 id="2-2-Unsupervised-pre-training"><a href="#2-2-Unsupervised-pre-training" class="headerlink" title="2.2 Unsupervised pre-training"></a>2.2 Unsupervised pre-training</h3><p> &emsp;&emsp; 无监督预训练是半监督学习的一种特殊情况，其目标是找到一个好的初始化点，而不是修改有监督学习目标。早期的工作探索了该技术在图像分类中的使用[20,49,63]和回归任务[3]。后续[15]研究表明，预训练可以作为一种正则化方案，在深度神经网络中具有更好的泛化效果。在最近的工作中，该方法已被用于帮助训练深度神经网络完成各种任务，如图像分类[69]、语音识别[68]、实体消歧[17]和机器翻译[48]。</p>
<p> &emsp;&emsp; 与我们最接近的工作是使用语言建模目标对神经网络进行预训练，然后在监督下对目标任务进行微调。Dai等[13]和Howard和Ruder[21]采用了这种方法来改进文本分类。然而，虽然与训练phase有助于捕获一些语言信息，但是他们的模型使用LSTM模型，这限制了模型的预测能力。相比之下，我们选择的Transformer网络允许我们捕获更大范围的语言结构，正如我们的实验所证明的那样。此外，我们还演示了我们的模型在更广泛的任务上的有效性，包括自然语言推断、释义检测和故事完成。其他方法[43,44,38]在训练目标任务上的监督模型时，使用来自2个预先训练语言或机器翻译模型的隐藏表征作为辅助特征。这涉及到每个单独目标任务的大量新参数，而在传输过程中我们需要对模型架构进行最小的更改。</p>
<h3 id="2-3-Auxiliary-training-objectives"><a href="#2-3-Auxiliary-training-objectives" class="headerlink" title="2.3 Auxiliary training objectives"></a>2.3 Auxiliary training objectives</h3><p> &emsp;&emsp; 增加辅助的无监督训练目标是半监督学习的另一种形式。在早期的工作中，Collobert和Weston[10]使用了各种各样的辅助NLP任务，如词性标记、分块、命名实体识别和语言建模来改进语义角色标记任务的效果。最近，Rei[50]在他们的目标任务目标中增加了一个辅助语言建模目标，并演示了序列标记任务的性能的提高。我们的实验也使用了一个辅助目标，但正如我们所展示的，未经监督的预训练已经学会了与目标任务相关的几个语言方面。</p>
<h2 id="3、Framework"><a href="#3、Framework" class="headerlink" title="3、Framework"></a>3、Framework</h2><p> &emsp;&emsp; 我们的训练过程包括两个阶段。第一阶段是在大语料库上学习高容量的语言模型。接下来是一个微调阶段，在这个阶段中，我们会使模型适应这个具有标记数据的任务。</p>
<h3 id="3-1-Unsupervised-pre-training"><a href="#3-1-Unsupervised-pre-training" class="headerlink" title="3.1 Unsupervised pre-training"></a>3.1 Unsupervised pre-training</h3><p> &emsp;&emsp; 给定一个非监督的语料，其token为$\ \mathcal{U} = {u_1,…,u_n}$ ，我们使用一个标准的语言建模目标，即最大化下面的似然函数：</p>
<script type="math/tex; mode=display">
L_1(\mathcal{U}) = \sum_i \log P(u_1|u_{i-k},...,u_{i-1};\Theta) \tag{1}</script><p> &emsp;&emsp; 其中$\ k$ 表示上下文窗口的大小， 我们使用参数为$\ \Theta$ 的神经网络建模条件概率$\ P$ ，我们使用梯度下降来训练这些参数。</p>
<p> &emsp;&emsp; 在我们的实验中，我们使用了多层Transformer decoder[34作为语言模型，这是一个transformer的变体[62]。这个模型对输入的上下文token采用了multi-headed self-attention操作，之后使用position-wise的前馈层来生成目标token输出的分布，即（这里只用了transformer的decoder）：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{split}
h_0 &= UW_e + W_p\\
h_l &= \text{transformer_block}(h_{l-1}) \ \forall i \in [1,n]\\ 
P(u) &= \text{softmax}(h_n W_e^T)
\end{split}
\end{equation}
\tag{2}</script><p> &emsp;&emsp; 其中，$\ U = (u<em>{i-k},…,u</em>{i-1})$ ，使token的上下文向量，$\ n$ 使transformer层的数量，$\ W_e$ 是词向量矩阵，$\ W_p$ 是positon embedding矩阵。</p>
<h3 id="3-2-Supervised-fine-tuning"><a href="#3-2-Supervised-fine-tuning" class="headerlink" title="3.2 Supervised fine-tuning"></a>3.2 Supervised fine-tuning</h3><p> &emsp;&emsp; 将公式1作为目标函数训练完模型后，我们就把参数应用到监督任务中，我们假设，带标签的数据集$\ \mathcal{C}$ ，在数据集中，每个实例都包含一个句子，其token为$\ x^1,…,x^m$ ，对应的标签为$\ y$ 。将该输入送入我们的预训练模型中得到transformer模块的输出$\ h_l^m$ ，然后将其送入到一个附加线性输出层中，该层的参数为$\ W_y$ ，来预测$\ y$ ：</p>
<script type="math/tex; mode=display">
P(y|x^1,...,x^m) = \text{softmax}(h_l^m W_y) \tag{3}</script><p> &emsp;&emsp; 那么，在该任务中的目标函数就是最大化下面的目标函数：</p>
<script type="math/tex; mode=display">
L_2(\mathcal{C}) = \sum_{(x,y)} \log P(y|x^1,...,x^m) \tag{4}</script><p> &emsp;&emsp; 另外，我们发现<strong>将语言模型的目标函数作为一个辅助目标函数来fine-tunning，是有帮助的，可以提升监督模型的泛化性并加速收敛。</strong>所以，我们的优化函数变成了：</p>
<script type="math/tex; mode=display">
L_3(\mathcal{C}) = L_2(\mathcal{C}) + \lambda * L_1(\mathcal{C}) \tag{5}</script><p> &emsp;&emsp; 总的来说，在fine-tunning期间，我们唯一需要调整的参数就是$\ W_y$ 以及分隔符$\ $$ 的词向量（见3.3节）。</p>
<h3 id="3-3-Task-specific-input-transformations"><a href="#3-3-Task-specific-input-transformations" class="headerlink" title="3.3 Task-specific input transformations"></a>3.3 Task-specific input transformations</h3><p> &emsp;&emsp; 对于某些任务，如文本分类，我们可以如上所述直接fine-tunning我们的模型。某些其他任务，如问题回答或文本蕴涵，具有结构化输入，如有序句子对，或文档、问题和答案的三元组。由<strong>于我们的预训练模型是在连续的文本序列上训练的，因此需要进行一些修改才能将其应用到这些任务中</strong>。之前的工作提出了transferred representations[44]之上的特定学习任务架构。这种方法重新引入了大量特定于任务的定制架构组件，但并且没有为这些附加的架构组件使用迁移学习。相反，我们使用 traversal-style的方法[52]，其中我们将结构化的输入转换为一个有序的序列，以便我们预先训练过的模型可以处理<strong>。这些输入转换允许我们避免跨任务对架构进行大量更改。</strong>我们在下面提供了这些输入转换的简要描述，图1提供了一个可视化的说明。所有的转换都包括添加随机初始化的开始和结束标记$\ (<s>,<e>)$。</p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/1.png?raw=true"  alt="1"></p>
<p><strong>Textual entailment</strong></p>
<p> &emsp;&emsp; 对于蕴含任务来说，我们把premise $\ p$ 和hypothesis $\ h$ 合起来，成为一个token句子，并使用分隔符token$\ $ $ 来分割。</p>
<p><strong>Similarity</strong></p>
<p> &emsp;&emsp; 对于相似性任务来说，一组输入中的两个句子是没有固定的先后顺序的。为了反映这一点，我们修改输入序列，使其包含两种可能的句子顺序(中间有一个分隔符)，并分别处理它们以生成两个序列表示$\ h_l^m$ ，这两个表示在输入到线性输出层之前按元素添加。</p>
<p><strong>Question Answering and Commonsense Reasoning</strong></p>
<p> &emsp;&emsp; 对于这些任务来说，给定一个语境文档$\ z$ ，一个问题$\ q$ ，一组可能的答案$\ {a_k}$ 。我们会把语境文档和问题与每一个可能的答案连起来，并在中间添加一个分隔符，如：$\ [z；q;$;a_k]$ 。每一个这样的句子都会被我们的模型单独的处理，然后通过softmax层进行规范化，产生一个可能答案的输出分布。</p>
<h2 id="4、Experiments"><a href="#4、Experiments" class="headerlink" title="4、Experiments"></a>4、Experiments</h2><h3 id="4-1-Setup"><a href="#4-1-Setup" class="headerlink" title="4.1 Setup"></a>4.1 Setup</h3><h4 id="4-1-1-Unsupervised-pre-training"><a href="#4-1-1-Unsupervised-pre-training" class="headerlink" title="4.1.1 Unsupervised pre-training"></a>4.1.1 Unsupervised pre-training</h4><p> &emsp;&emsp; 我们使用BooksCorpus数据集[71]来训练语言模型。它包含了7000多本独特的未出版的书籍，包括各种类型的书，冒险、幻想和浪漫。至关重要的是，它包含了长序列的连续文本，这使得生成模型能够以远程信息为条件进行学习。另一种数据集，1B大小的Word Benchmark，被类似的方法使用，ELMo[44]，与BooksCorpus大约是相同的大小，但打乱了句子，破坏了远程结构。我们的语言模型在该语料库上实现了一个非常低的token界别的复杂度18.4。</p>
<h4 id="4-1-2-Model-specifications"><a href="#4-1-2-Model-specifications" class="headerlink" title="4.1.2 Model specifications"></a>4.1.2 Model specifications</h4><p> &emsp;&emsp; 我们的模型很大程度上<strong>遵循了Transformer的原始工作</strong>[62]。我们训练了一个<strong>12层的只有decoder的Transformer</strong>，同时<strong>使用了masked self-attention heads</strong>(768 dimensional states and 12 attention heads)。对于 <strong>position-wise的前馈网络，我们使用3072维的inner states</strong>。我们使用<strong>Adam优化方案</strong>[27]，最大学习率为2.5e-4。<strong>学习率在前2000个epoch线性增加，之后使用cosine schedule退火到0</strong>。我们对由<strong>512个token组成的64个随机抽样的连续序列进行100个epoch的训练</strong>。由于在整个模型中广泛使用了layernorm[2]，因此$\ N(0,0.02)$ 的简单权重初始化就足够了。我们使用了40000个字节对编码(BPE)词汇表，使<strong>用残差链接、embedding、0.1的dropout的正则化方法</strong>。我们还<strong>采用了[37]中提出的L2正则化的修改版本</strong>，参数设置为$\ w  = 0.01$ 。对于激活函数，我们使用<strong>Gaussian Error Linear Unit (GELU)</strong>[18]。我们<strong>使用了可学习的position embeddings 代替了原始工作中提出的正弦版本</strong>。我们<strong>使用ftfy  library来清理BooksCorpus中的原始文本，标准化一些标点符号和空格，并使用spaCy tokenizer</strong></p>
<h4 id="4-1-3-Fine-tuning-details"><a href="#4-1-3-Fine-tuning-details" class="headerlink" title="4.1.3 Fine-tuning details"></a>4.1.3 Fine-tuning details</h4><p> &emsp;&emsp; 我们还是使用的非监督与训练中的超参设定，在分类器上增加0.1比例的dropout，在大多数任务上，学习率设置为6.25e-5，batch设置为32。我们的模型fine-tunning的很快，只需要3个epoch。同时，我们使用了一个线性学习率衰减策略。$\ \lambda = 0.5$ 。</p>
<h3 id="4-2-Supervised-fine-tuning"><a href="#4-2-Supervised-fine-tuning" class="headerlink" title="4.2 Supervised fine-tuning"></a>4.2 Supervised fine-tuning</h3><p> &emsp;&emsp; 我们在各种监督任务上进行实验，包括自然语言推理、问题回答、语义相似度和文本分类。其中一些任务可以在最近发布的GLUE多任务基准测试[64]中使用。图1提供了所有任务和数据集的概述。</p>
<h4 id="4-2-1-Natural-Language-Inference"><a href="#4-2-1-Natural-Language-Inference" class="headerlink" title="4.2.1 Natural Language Inference"></a>4.2.1 Natural Language Inference</h4><p> &emsp;&emsp; 自然语言推理(NLI)的任务，又称识别文本蕴涵，包括阅读一对句子，从蕴涵、矛盾或中性的一个句子来判断句子之间的关系。尽管最近有很多人对此感兴趣[58,35,44]，但由于词汇暗含、共指、词汇和句法歧义等现象的广泛存在，这项任务仍然具有挑战性。我们评估了五个不同来源的数据集，包括image captions (SNLI), transcribed speech, popular fiction, and government  reports (MNLI), Wikipedia articles (QNLI), science exams (SciTail) or news  articles (RTE).</p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/2.png?raw=true"  alt="2"></p>
<h4 id="4-2-2-Question-answering-and-commonsense-reasoning"><a href="#4-2-2-Question-answering-and-commonsense-reasoning" class="headerlink" title="4.2.2 Question answering and commonsense reasoning"></a>4.2.2 Question answering and commonsense reasoning</h4><p> &emsp;&emsp; 另一个需要单句和多句推理的任务是回答问题。</p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/3.png?raw=true"  alt="3"></p>
<h4 id="4-2-3-Semantic-Similarity"><a href="#4-2-3-Semantic-Similarity" class="headerlink" title="4.2.3 Semantic Similarity"></a>4.2.3 Semantic Similarity</h4><p> &emsp;&emsp; 语义相似度(或意译检测)任务包括预测两个句子在语义上是否等价。挑战在于认识概念的重新措辞、理解否定和处理句法歧义。</p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/4.png?raw=true"  alt="4"></p>
<h2 id="5、Analysis"><a href="#5、Analysis" class="headerlink" title="5、Analysis"></a>5、Analysis</h2><h3 id="5-1-Impact-of-number-of-layers-transferred"><a href="#5-1-Impact-of-number-of-layers-transferred" class="headerlink" title="5.1 Impact of number of layers transferred"></a>5.1 Impact of number of layers transferred</h3><p> &emsp;&emsp; 我们观察了将可变数量的层从无监督的预训练迁移到有监督的目标任务的影响。图2(左)说明了我们的方法在MultiNLI和RACE上的性能，它与迁移的层数有关。我们观察到的标准结果是迁移embedding提高了性能，在MultiNLI.任务上，<strong>每个Transformer层提供了可达9%的性能提升。这表明预训练的模型中的每一层都包含解决目标任务的有用功能。</strong></p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/5.png?raw=true"  alt="5"></p>
<h3 id="5-2-Zero-shot-Behaviors"><a href="#5-2-Zero-shot-Behaviors" class="headerlink" title="5.2 Zero-shot Behaviors"></a>5.2 Zero-shot Behaviors</h3><p> &emsp;&emsp; <strong>我们想更好地理解为什么Transformer的语言模型预训练是有效的。一种假设是，潜在的生成模型能够学着去执行我们评估的许多任务，以提高其语言建模能力，而与LSTMs相比，transformer更结构化的注意记忆有助于迁移。</strong>我们设计了一系列启发式解决方案，使用潜在的生成模型来执行任务，而无需监督微调。我们在图2(右)中可视化了这些启发式解决方案在生成式预训练过程中的有效性。我们观察到，这些启发式的性能是稳定的，并且在训练过程中稳步增加，这表明生成式预训练支持了对各种任务相关功能的学习。我们还观察到，LSTM在其zero-shot性能方面表现出更高的方差，这表明Transformer结构归纳性的偏置有助于迁移。</p>
<p> &emsp;&emsp; 对于CoLA(语言可接受性），用生成模型分配和预测的平均token日志概率对例子进行评分。对于SST-2（情感分析），我们在每一个例子中都非常附加了标记，并且将语言模型的输出分布限制为只有正和负两个词，并猜测它分配给更高概率的标记作为预测。对于race（question answering），我们选择生成模型在文档和问题条件下分配最高平均token日志概率的答案。对于DPRD[46]（winograd模式），我们用两个可能的引用来替换定代词，并预测生成模型在替换后将较高的平均token日志概率分配给序列的其余部分的分辨率。</p>
<h3 id="5-3-Ablation-studies"><a href="#5-3-Ablation-studies" class="headerlink" title="5.3 Ablation studies"></a>5.3 Ablation studies</h3><p> &emsp;&emsp; 我们进行了三种不同的Ablation研究(表5)。首先，在微调过程中，我们检查了我们的方法在没有辅助LM目标的情况下的性能。我们观察到辅助目标对NLI任务和QQP有帮助。总的来说，<strong>这一趋势表明，较大的数据集从辅助目标中受益，而较小的数据集则不能</strong>。其次，通过与使用相同框架的单层2048单元LSTM进行比较，分析了Transformer的性能。我们观察到使用LSTM而不是Transformer时平均分数下降5.6。LSTM只在一个数据集MRPC上优于Transformer。最后，我们还将其与transformer架构进行了比较，我们直接在受监督的目标任务上进行了训练，而没有进行预训练。我们观察到，缺乏预训练会影响所有任务的表现，与我们的完整模型相比，结果导致14.8%的下降。</p>
<p><img src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/loading.gif?raw=true" class="lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/6.png?raw=true"  alt="6"></p>
<h2 id="6、Conclusion"><a href="#6、Conclusion" class="headerlink" title="6、Conclusion"></a>6、Conclusion</h2><p> &emsp;&emsp; 我们引入了一个框架，通过生成性预训练和区分性微调，以单一未知任务模型实现强大的自然语言理解。通过对不同语料库进行长距离连续文本的预先训练，我们的模型获得了重要的全局知识和处理长距离依赖关系的能力，然后成功地将这些知识迁移到解决特定性任务，如问答、语义相似性评估、限定确定和文本分类。改进了我们所研究的12个数据集中的9个的最新技术。利用无监督（预）训练提高识别任务的性能一直是机器学习研究的一个重要目标。我们的工作表明，实现显著的性能提升确实是可能的，并且提供了关于什么模型（(Transformers)）和数据集（具有长期依赖性的文本）最适合这种方法的提示。我们希望这将有助于对自然语言理解和其他领域的无监督学习进行新的研究，进一步提高我们对无监督学习如何以及何时起作用的理解。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">白丁</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://baidinghub.github.io/2020/09/21/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/">http://baidinghub.github.io/2020/09/21/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://baidinghub.github.io" target="_blank">BaiDing's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a><a class="post-meta__tags" href="/tags/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">NLP基础知识</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDyIdOn/M/aXcGQOiSDVMqvN2gxDdiESHUfFuB2YMy48fvNN9SZOQUbVlGF4Pk6nDXIAir+br/EWuEnNLtgOCYMo/BTxl29gqS/QGHPiDaIQedzmLcuRZpfDuGit61N/b9pyktpZLagBgbl5Ox9mAgWQxXyhxYB092gyOXqrBULBeZUYQ+H7Eupha10QTQghHv4nLk+oYWo2UXEiijQpE3qMXT32G8v8k0KbRdd1hIFPyNEx6eZ6Buc2ZdbMtoutdGjvdnw5B1+dxgl1egESPChzcwCMxt3NW/3faQ5lsjRhQD4fRU+Ua/aqXe+0xg2+xr0BTjNr/JZIAaNiLuo71lH 1564026260@qq.com" async="async"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/wechat.png?raw=true" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/alipay.jpg?raw=true" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/09/22/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89BERT/"><img class="prev_cover lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E5%85%AD%EF%BC%89BERT/cover.png?raw=true" onerror="onerror=null;src='https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/404.jpg?raw=true'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">NLP词向量篇（六）BERT</div></div></a></div><div class="next-post pull_right"><a href="/2020/09/21/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89ELMo/"><img class="next_cover lazyload" data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89ELMo/cover.png?raw=true" onerror="onerror=null;src='https://github.com/BaiDingHub/Blog_images/blob/master/BlogSource/404.jpg?raw=true'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">NLP词向量篇（四）ELMo</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/09/11/NLP特征提取器篇（一）RNN/" title="NLP特征提取器篇（一）RNN"><img class="relatedPosts_cover lazyload"data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%99%A8%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89RNN/cover.png?raw=true"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-11</div><div class="relatedPosts_title">NLP特征提取器篇（一）RNN</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/12/NLP特征提取器篇（三）Transformer/" title="NLP特征提取器篇（三）Transformer"><img class="relatedPosts_cover lazyload"data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%99%A8%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89Transformer/cover.png?raw=true"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-12</div><div class="relatedPosts_title">NLP特征提取器篇（三）Transformer</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/11/NLP特征提取器篇（二）LSTM/" title="NLP特征提取器篇（二）LSTM"><img class="relatedPosts_cover lazyload"data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E5%99%A8%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89LSTM/cover.png?raw=true"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-11</div><div class="relatedPosts_title">NLP特征提取器篇（二）LSTM</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/01/NLP词向量篇（一）Word2Vec/" title="NLP词向量篇（一）Word2Vec"><img class="relatedPosts_cover lazyload"data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89Word2Vec/cover.png?raw=true"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-01</div><div class="relatedPosts_title">NLP词向量篇（一）Word2Vec</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/22/NLP词向量篇（七）RoBERTa/" title="NLP词向量篇（七）RoBERTa"><img class="relatedPosts_cover lazyload"data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%83%EF%BC%89RoBERTa/cover.png?raw=true"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-22</div><div class="relatedPosts_title">NLP词向量篇（七）RoBERTa</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/02/NLP词向量篇（三）FastText/" title="NLP词向量篇（三）FastText"><img class="relatedPosts_cover lazyload"data-src="https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89FastText/cover.png?raw=true"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-02</div><div class="relatedPosts_title">NLP词向量篇（三）FastText</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'd3948be001a91411dfd9',
  clientSecret: 'ebddf2a2a5a039922fb373a8a8c0efcc439bf6ca',
  repo: 'BaiDingHub.github.io',
  owner: 'BaiDingHub',
  admin: ['BaiDingHub'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" style="background-image: url(https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89GPT-1/cover.png?raw=true)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 白丁</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://jerryc.me/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js" ></script><script src="/js/utils.js" ></script><script src="/js/main.js" ></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/search/algolia.js"></script></body></html>