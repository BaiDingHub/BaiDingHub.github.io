---
title: NLP词向量篇（一）Word2Vec
date: 2020-09-01 05:20:00
tags:
 - [深度学习]
 - [NLP基础知识]
categories: 
 - [深度学习,NLP基础知识]
keyword: "深度学习,自然语言处理，词向量"
description: "NLP词向量篇（一）Word2Vec"
cover: https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89Word2Vec/cover.png?raw=true
---

<meta name="referrer" content="no-referrer"/>



# Efficient Estimation of Word Representations in Vector Space
> 时间：2013年
>
> 关键词：NLP, Word Embedding
>
> 论文位置：https://arxiv.org/pdf/1301.3781.pdf%C3%AC%E2%80%94%20%C3%AC%E2%80%9E%C5%93
>
> 引用：Mikolov T, Chen K, Corrado G, et al. Efficient estimation of word representations in vector space[J]. arXiv preprint arXiv:1301.3781, 2013.

**摘要：**我们**提出了两种新的模型体系结构**，用于从非常大的数据集**计算单词的连续向量表示**。这些representation的质量通过一个单词相似性任务来衡量，然后将结果与之前基于不同类型的神经网络的表现最好的技术进行比较。我们发现我们能够以较低的计算代价却能够得到准确性上的巨大提升，我们只需要不到一天的时间，就能够从从16亿字数据集中学习到优质词向量。此外，我们发现，这些词向量在我们的（测量句法和语义词的相似性）测试集上提供了SOTA的性能

**索引**- 自然语言处理，词向量

## 内容分析

 &emsp;&emsp; 在这篇论文出现之前，前馈NNLM与RNNLM已经出现用来生成词向量了。但是，我们都知道在NLP领域，词汇量巨大，语料库巨大，可以用billion甚至trillion计数，而前馈NNLM与RNNLM中都包含了非线性的隐藏层（带有激活函数的神经元），这会使得模型的计算复杂度非常大，所以，在极大的数据集上训练的非常慢，本篇论文就是基于计算复杂度做的改进。

**CBOW**

 &emsp;&emsp; 词袋模型，Bag-of-Words Model。包含有input、projection、output层，对于一个单词$ w_t$  ，在一个句子中包含有上下文$\ ...,w_{t-2},w_{t-1},.,w_{t+1},w_{t+2},... $ 。CBOW的任务目标就是根据该单词的N个上下文来预测该单词，其预测过程可以这样描述：

1. 为模型输入N个上下文（作者选择了4个上文、4个下文），经过input层，将其转换为V维的one hot向量（总词汇量数目记为V）。
2. 每个单词都对应一个特征向量，也就是词向量，这存放在projection层的特征向量矩阵中，因此，经过projetion层后，我们得到N个D维的词向量，在CBOW模型中，将这个N个词向量相加，得到一个总的特征向量。
3. 将该D维的特征向量送入output层，output层包含有V个神经元，因此输出为V维向量，也就是预测单词的概率
4. 该任务的目标就是使得输出向量在单词$\ w_t$ 位置上的概率值最大，在整个数据集上，那就是让似然函数$\ L = \frac{1}{T}\sum_t \log p(w_t|Context(w_t))$ 最大。

 &emsp;&emsp; **特点分析**：词袋模型利用了文本中出现的单词，也就是说文本中单词出现的频率越高，代表该单词越重要，所占有的权重越大，但是这种方式只能够表达词在当前文本中的重要程度，许多停用词由于词频较高，权重很大，可以使用TF-IDF进行优化。同时，词袋模型并不能够提供词序信息

**Skip-gram**

 &emsp;&emsp; Skip-gram模型与CBOW相似，只是最后的训练目标不同，CBOW的训练目标是根据单词$\ w_t$ 的上下文来预测该单词，最大化该单词的似然函数。但是，Skip-gram是通过该单词$\ w_t$ ，来预测该单词的上下文。其他的过程一样。即优化目标变为使$\ L = \frac{1}{T}\sum_t \log p(Context(w_t)|w_t)$ 。

两个模型的大体结构如下：

![2](https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89Word2Vec/2.png?raw=true)

## 1、Introduction

 &emsp;&emsp; 许多当前的NLP系统和技术将单词视为原子单位——单词之间没有相似性的概念，因为它们在词汇表中被表示为索引。这一选择有几个很好的理由——简单性、健壮性，以及观察到在大量数据上训练的简单模型优于在较少数据上训练的复杂系统。一个例子是用于统计语言建模的流行的N-gram模型——今天，在几乎所有可用数据(数万亿个单词[3])上训练N-gram是可能的。

 &emsp;&emsp; 然而，简单的技术在许多任务中都有其局限性。例如，用于自动语音识别的相关域内数据的数量是有限的——性能通常由高质量转录语音数据的大小(通常只有数百万字)所决定。在机器翻译中，许多语言的现有语料库只包含数十亿或更少的单词。因此，在某些情况下，简单地扩大基本技术的规模将不会产生任何显著的进展，因此我们必须关注更高级的技术。

 &emsp;&emsp; 随着近年来机器学习技术的进步，在更大的数据集上训练更复杂的模型已经成为可能，而且它们通常比简单模型表现得更好。最成功的概念可能是使用单词[10]分布的representation。例如，基于神经网络的语言模型显著优于N-gram模型

### 1.1 Goals of the Paper

 &emsp;&emsp; 本文的主要目标是介绍一些技术，这些技术可用于**从具有数十亿个单词数目和数百万个单词种类的庞大数据集中学习高质量的单词向量**。据我们所知，以前提出的架构都没有成功地训练过超过数亿个单词（单词向量的维数在50  - 100之间）。

 &emsp;&emsp; 我们使用最近提出的技术来测量得到的词向量的效果，我们期望不仅相似的单词会趋向于彼此接近，而且单词可以有多个程度的相似[20]。这已经在早期的inflectional languages中提到了——例如，名词可以有多个词尾，如果我们在原始向量空间的子空间中搜索相似的词，就有可能找到词尾相似的词[13,14]。

 &emsp;&emsp; 有些令人惊讶的是，人们发现词语表征的相似性超出了简单的句法规律。使用单词偏移技术对单词向量进行简单的代数运算，例如，vector(“King”)-  vector(“Man”)+ vector(“Woman”)得到的向量最接近单词Queen的向量表示。

 &emsp;&emsp; 在本文中，我们试图通过开发新的模型架构来保持单词之间的线性规律，以最大限度地提高这些向量运算的准确性。我们设计了一个新的综合测试集来衡量语法和语义规则，发现，我们能够得到许多这样的规则，而且精度很高。此外，我们讨论了训练时间和准确性如何依赖于字向量的维数和训练数据的数量。

### 1.2 Previous Work

 &emsp;&emsp; 将单词表示为连续向量已经有很长的历史[10,26,8]。在[1]中提出了一种非常流行的估计神经网络语言模型的模型体系结构（NNLM），该结构使用带有线性投影层和非线性隐层的前馈神经网络来联合学习单词向量表示和统计语言模型。这项工作之后又有许多其他的工作。

 &emsp;&emsp; NNLM的另一个有趣的架构在[13,14]中提出，其中单词向量首先使用具有单个隐含层的神经网络学习。然后使用单词向量来训练NNLM。因此，即使不构造完整的NNLM，也可以学习单词向量。在这项工作中，我们直接扩展了这个架构，并且只关注使用简单模型学习单词向量的第一步。

 &emsp;&emsp; NNLM的另一个有趣的架构在[13,14]中提出，其中单词向量首先使用具有单个隐含层的神经网络学习。然后使用单词向量来训练NNLM。因此，即使不构造完整的NNLM，也可以学习单词向量。在这项工作中，我们直接扩展了这个架构，并且只关注使用简单模型学习单词向量的第一步。

 &emsp;&emsp; 后来的研究表明，**单词向量可以显著改善和简化许多NLP应用**[4,5,29]。使用不同的模型架构对词向量本身进行估计，并在不同的语料库上进行训练[4,29,23,19,9]，得到的部分词向量可用于将来的研究和比较。然而，据我们所知，这些架构比[13]中提出的架构在训练方面的计算成本要高得多，除了某些版本的对数双线性模型，其中对角权矩阵使用[23]。

## 2、Model Architectures

 &emsp;&emsp; 许多不同类型的模型被提出用于估计词的连续表示，包括众所周知的Latent Semantic Analysis （LSA）和Latent Dirichlet Allocation （LDA）。在本文中，我们关注的是神经网络学习到的单词分布的representation，因为之前已经表明，在保留单词之间的线性规律方面，神经网络的表现明显优于LSA  [20,31];此外，LDA在大型数据集上的计算开销非常大。

 &emsp;&emsp; 与[18]类似，为了比较不同的模型架构，我们首先**将模型的计算复杂度定义为需要访问的参数的数量**，以充分训练模型。接下来，我们将尝试**最大化精确度，同时最小化计算复杂度**。

 &emsp;&emsp; 对于以下所有模型，训练复杂度为：
$$
O = E \times T \times Q
$$
 &emsp;&emsp; 其中E为训练epoch的个数，T为训练集中单词的个数，Q为每个模型架构进一步定义。常见的选择是E = 3

~50和T高达10亿。所有模型都使用随机梯度下降和反向传播进行训练。

### 2.1 Feedforward Neural Net Language Model (NNLM)

 &emsp;&emsp; 在[1]中提出了概率前馈神经网络语言模型。它**由输入层、投影层、隐藏层和输出层**组成。在输入层，使用1-of-V编码对前面的N个单词进行编码，其中V为词汇表的大小。然后使用共享的投影矩阵将输入层投影到维数N×D的投影层P。由于在任何给定时间只有N个输入是活动的，合成投影层是一个相对cheap的操作。

 &emsp;&emsp; 由于投影层是全连接层，NNLM体系结构使得投影层和隐层之间的计算变得复杂。对于N =  10的这种常见选择，投影层(P)的大小可能是500到2000，而隐藏层的大小H通常是500到1000个单位。并利用隐含层计算词汇中所有单词的概率分布，得到维数为V的输出层。因此，每个训练示例的计算复杂度为
$$
Q = N \times D + N \times D \times H + H \times V
$$
> 复杂度被定义为整个模型中的参数，其中N代表的是N-gram中的N，即上下文长度，D表示的是代表每个单词的向量的维度，类似于词向量维度。单词经过输入层转换成one hot编码，无计算复杂度，将one hot编码，经过投影层，转换成（1，N * D）长度的向量，每个单词对应一个D维的特征向量，共 $\ N \times D$ 个参数。之后将该向量经过隐藏层，隐藏层有H个神经元，每个神经元的参数都是 $\ N \times D$ ，因此这一步的参数为 $\ N \times D \times H$ ，经过隐藏层后，向量变为（1，H），经过包含V个神经元的输出层，得到输出（1，V），这一步的参数为$\ H \times V$ 。
>
> 这个方法的作用是使用该单词的上下文单词的信息，预测该单词属于哪一个单词，模型的输出（1，V）表示的是预测单词的概率。
>
> 这个模型的训练目标就是，使得输出的单词概率在$\ w_t$ 上的概率值最大，放到整个数据集上的话，就是使整个似然函数最大化。

 &emsp;&emsp; 主要项是H乘以V。然而，提出了一些实际的解决方案来避免它;要么使用hierarchical softmax[25,23,18]，要么使用在训练中没有标准化的模型来完全避免标准化模型[4,9]。使用词汇表的二叉树表示，需要计算的输出单元的数量可以减少到log2(V)左右。因此，大部分复杂性是由N×D×H这一项引起的。

 &emsp;&emsp; 在我们的模型中，我们使用hierarchical softmax，其中词汇表表示为Huffman二叉树。这与之前的观察结果一致，即在神经网络语言模型[16]中，单词的频率对于获取类非常有效。Huffman树将简短的二进制编码分配给频繁的单词，这进一步减少了需要计算的输出单元数:平衡二值树需要计算log2(V)输出，而基于Huffman树的hierarchical  softmax只需要大约$\ log2(Unigram\_perplexity(V ))$ 。例如，当词汇表大小为100万个单词时，这将导致评估速度提高约两倍。虽然这对于神经网络LMs来说并不是关键的加速，因为计算瓶颈在N×D×H项，但我们稍后将提出没有隐藏层的架构，因此严重依赖softmax归一化的效率。

> 通过上面的复杂度分析，我们可以得到计算复杂度主要体现在两个部分，一个是输出层的参数$\ H \times V$ ，另一个是隐藏层的参数$\ N \times D \times H$ 。我们可以利用二叉树减少输出单元的个数为$\ log_2(V)$ ，这样输出层就OK了，只剩下隐藏层这个极大的限制了。

### 2.2 Recurrent Neural Net Language Model (RNNLM)

 &emsp;&emsp; 基于循环神经网络的语言模型被提出，以克服前馈NNLM的某些限制，如需要指定上下文长度(模型的阶数N)，以及RNNs在理论上可以比浅神经网络有效地表示更复杂的模式[15,2]。RNN模型没有投影层;只有输入、隐藏和输出层。这类模型的特殊之处在于使用延时连接将隐含层连接到自身的循环矩阵。这使得循环模型可以形成某种短期记忆，因为来自过去的信息可以通过根据当前输入和前一时间步长的隐含层状态进行更新的隐含层状态来表示。

 &emsp;&emsp; RNN模型每训练例的复杂度为
$$
Q = H \times H + H \times V
$$
 &emsp;&emsp; 其中representation维度D与隐含层H具有相同的维数，通过使用softmax分层，主体H×V可以有效地降为H×log2(V)。大部分的复杂性来自于H乘以H。

> 这个过程，是模型的输入直接就是该单词的词向量，输入为（1，D），经过包含H个神经元的隐藏层，得到输出（1，H），设定H=D，之后经过包含V个神经元的输出层，得到概率输出（1，V）。
>
> 注意：我们这里只使用了该单词的词向量，并没有直接使用历史单词的词向量，这是因为RNN的模型机制问题，其能够将历史向量的信息引入到模型中，因此，我们并不需要显式的输入历史单词的词向量。
>
> 由于输出层的问题我们已经解决了，所以计算复杂度的限制还是处于隐藏层中。

### 2.3 Parallel Training of Neural Networks

 &emsp;&emsp; 为了在巨大的数据集上训练模型，我们在一个名为DistBelief[6]的大规模分布式框架上实现了几个模型，包括前馈NNLM和本文提出的新模型。该框架允许我们并行运行同一模型的多个副本，每个副本通过一个中央服务器同步其梯度更新，该服务器保存所有参数。在这个并行训练中，我们使用了一个名为Adagrad[7]的自适应学习率程序，即迷你批量异步梯度下降。在这种框架下，通常使用100个或多个模型副本，每个模型副本使用数据中心中不同机器上的多个CPU核。



## 3、New Log-linear Models

 &emsp;&emsp; 在本节中，我们**提出了两个新的学习词向量（distributed representations of words）的模型架构，通过最小化计算复杂度的方式实现**。上一节的主要观察结果是，**大部分复杂性是由模型中的非线性隐藏层造成的**。虽然这是神经网络如此吸引人的原因，但我们决定探索更简单的模型，这些模型可能不能像神经网络那样精确地表示数据，但可能可以更有效地训练数据。

 &emsp;&emsp; 新架构直接按照那些在我们之前提出的工作[13、14]，在那里发现神经网络语言模型的训练可以分为两个步骤：第一，使用简单的模型学习词向量，然后在这些词向量的基础上学习N-gram NNLM。尽管有大量的工作集中在学习词向量上，但我们认为[13]中提出的方法是最简单的。值得注意的是，相关的模型也在更早的时候被提出[26,8]。

### 3.1  Continuous Bag-of-Words Model

 &emsp;&emsp; 第一个提出的架构类似于前馈NNLM，其中**非线性隐藏层被删除**，投影层为所有词(不仅仅是投影矩阵)共享;因此，所有的单词被投射到相同的位置(它们的向量被平均)。我们称这种架构为**词袋模型**，因为前面的单词的顺序不会影响projection.。此外，我们也会使用后面的单词；**通过构建一个输入为四个后面的单词和四个前面的单词的对数线性分类器**，我们获得了在下一节中介绍的任务的最佳性能，其中训练标准是正确地分类当前(中间)单词。训练复杂度为
$$
Q = N \times D + D \times log_2(V)
$$
 &emsp;&emsp; 我们将这个模型称为CBOW，因为与standard bag-of-words model不同，它使用上下文的词向量。模型架构如图1所示。注意，输入层和投影层之间的权值矩阵对于所有单词位置都是共享的，方式与NNLM中相同。

> 这一部分跟NNLM相似，在投影层部分，将N个单词的词向量取平均，这样，这N个单词的顺序不会影响最后的结果。同时，去掉了隐藏层部分，这会使模型的复杂度大大降低。
>
> 在词袋模型中，N个单词的采用了该单词上文的四个单词和下文的四个单词。

### 3.2 Continuous Skip-gram Model

 &emsp;&emsp; 第二种架构与CBOW类似，但**它不是根据上下文来预测当前的单词，而是根据同一句子中的另一个单词来最大程度地分类一个单词**。更准确地说，我们**将每个当前单词作为一个具有连续投影层的对数线性分类器的输入，预测当前单词前后一定范围内的单词**。我们发现，**增加范围可以提高结果词向量的质量，但也增加了计算复杂度**。由于距离较远的单词通常与当前单词的关系比接近当前单词的关系要小，因此我们通过在训练例子中较少地从这些单词中取样来给予距离较远的单词较少的权重。

 &emsp;&emsp; 这个结构的训练复杂度可以描述为：
$$
Q = C \times (D + D \times log_2(V))
$$
 &emsp;&emsp; 其中$\ C$ 是单词预测范围的距离，因此，如果选择$\ C = 5$ ，那么我们将会为每一个训练的单词在$\ [1,C]$ 范围内随机的选择一个数字$\ R$ ，之后从前面和后面的单词中分别选择$\ R$ 个单词，将其作为label，因此，我们需要进行$\ 2\times R$ 次预测（将当前的单词作为输入，这$\ 2 \times R$ 个单词分别作为每次预测的label）。在接下来的实验中，我们设置$\ C = 10$ 。

> Skip-gram模型的模型结构与CBOW相似，但是训练目标出现了不同。CBOW的训练目标是根据单词的上下文来预测该单词，最大化该单词的似然函数。但是，Skip-gram是通过该单词，来预测该单词的上下文。其中C表示的就是要预测的上下文的长度，作者选择的是该单词上文的R个单词和下文的R个单词。
>
> 很明显，Skip-gram的训练目标比CBOW大得多，因此训练复杂度也就越高，训练时间也就越长。

![3](https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89Word2Vec/3.png?raw=true)

## 4、Results

 &emsp;&emsp; 为了比较不同版本的词向量的表现，以往的论文通常会使用一个表来显示示例词和它们最相似的词，并直观地理解它们。尽管很容易表明单词France与Italy或其他一些国家相似，但在进行更复杂的相似任务时，将这些向量置于其中就更具挑战性了，如下所示。我们遵循之前的观察，即单词之间可能有许多不同类型的相似之处，例如，单词big与bigger的相似之处，就像单词small与smaller的相似之处一样。另一种类型的关系可以是单词对big  - biggest和small -  smallest[20]。我们进一步把两组关系相同的单词表示成问句，我们可以问:“和small相似的单词是什么?和最大相似的意思是什么?”

 &emsp;&emsp; 有些令人惊讶的是，这些问题可以**通过对单词的词向量执行简单的代数运算来回答**。要想找到一个与small相似的词，并且最大与big相似，我们只需计算$\ vector X  = vector(“biggest”)−vector(“big”)+  vector(“small”)$ 。然后，在向量空间中搜索以余弦距离度量最接近$\ X$ 的单词，并使用它作为问题的答案(我们在搜索过程中丢弃输入的问题单词)。当单词向量训练良好时，就有可能使用这种方法找到正确的答案(word smallest)。

 &emsp;&emsp; 最后,我们发现,当我们在大数据集上训练高维向量时，生成的向量可以用来回答非常微妙的词与词之间的语义关系，如一个城市和它属于国，如法国和德国柏林巴黎。具有这种语义关系的词向量可用于改进许多现有的NLP应用程序，如机器翻译、信息检索和问题回答系统，并可能使其他未来尚未发明的应用程序成为可能。

### 4.1 Task Description

 &emsp;&emsp; 为了衡量词向量的性能，我们定义了一个包含五种类型语义问题和九种类型语法问题的综合测试集。表1显示了每个类别的两个示例。共有8869个语义问题和10675个句法问题。每个类别中的问题都是通过两个步骤创建的:首先，手动创建一个类似的单词对列表。然后，将两组单词连在一起，形成一个大的问题列表。例如，我们将68个美国大城市及其所属的州列出来，随机选择两组字词，组成约2.5K个问题。我们在测试集中只包含单个标记词，因此不存在多词实体(例如New  York)

 &emsp;&emsp; 我们评估所有的问题类型的整体准确性，以及分每个问题类型(语义，句法)的准确性。只有当用上述方法计算出的与向量最接近的词与问题中的正确词完全相同时，才假定问题正确回答，因此同义词被视为错误。这也意味着达到100%的准确率是不可能的，因为目前的模型没有任何关于词法的输入信息。然而，我们认为词向量对于某些应用的有用性应该与这个精度度量正相关。进一步的进展可以通过合并关于词的结构的信息，特别是对于句法问题。

![2](https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89Word2Vec/2.png?raw=true)

### 4.2 Maximization of Accuracy

 &emsp;&emsp; 我们使用谷歌新闻语料库来训练词汇向量。这个语料库包含大约6B个tokens。我们已经将词汇量限制在100万个最常见的单词。显然，我们面临着时间限制的优化问题，因为可以预期，使用更多的数据和更高维度的词向量将提高准确性。为了快速评估模型架构的最佳选择以获得尽可能好的结果，我们首先评估了在训练数据子集上训练的模型，使用词汇限制在最频繁的30k单词。使用CBOW体系结构，在不同的词向量维数选择和训练数据量增加的情况下，结果如表2所示。

![4](https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89Word2Vec/4.png?raw=true)

 &emsp;&emsp; 可以看到，在某个点之后，增加更多的维度或增加更多的训练数据，所提供的改善在递减。因此，我们必须同时增加向量维数和训练数据的数量。虽然这个观察结果看起来微不足道，但必须注意的是，目前流行的做法是在相对大量的数据上训练单词向量，但使用较低的维度，例如50-100。就像之前说的时间复杂度的计算，增加训练集的数目也会导致计算复杂度的增加。

 &emsp;&emsp; 对于表2和表4中报告的实验，我们使用了三个具有随机梯度下降和反向传播的训练epoch。我们选择初始学习率为0.025，并线性地降低它，使它在最后一个训练epoch结束时趋于0。

### 4.3 Comparison of Model Architectures

 &emsp;&emsp; 首先，我们比较了不同的模型架构生成的词向量的性能，统一使用同样大小的训练数据和同样维度的词向量（640维）。在接下来的实验中，我们使用了新的Semantic-Syntactic Word Relationship测试集中的所有问题，不限于30k个词汇，我们还引入了文献[20]中的测试集（关注于单词之间的语法相似性）

 &emsp;&emsp; 训练数据由几个LDC语料库组成，在[18]中有详细的描述(320M words, 82K  vocabulary)。我们使用这些数据来与之前在单一CPU上花费8周时间训练的循环神经网络语言模型进行比较。我们使用DistBelief并行训练[6]训练了具有相同数量的640个隐藏单元的前馈NNLM，使用8个前面的单词(这样，NNLM比RNNLM有更多的参数，因为投影层的大小是640×8)。

 &emsp;&emsp; 从表3中可以看出，RNN([20]中使用的)的词向量在句法问题上表现良好。NNLM向量的性能明显优于RNN——这并不奇怪，因为RNNLM中的词向量直接连接到一个非线性隐藏层。CBOW体系结构在句法任务上比NNLM工作得更好，在语义任务上也差不多。最后，在语法任务上，Skip-gram体系结构比CBOW模型稍微差一点(但仍然比NNLM模型好)，在测试的语义部分比所有其他模型好得多。

![5](https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89Word2Vec/5.png?raw=true)

 &emsp;&emsp; 接下来，我们仅仅使用一个CPU来训练我们的模型， 与公开可用的词汇向量进行比较。在表4中给出了结果，可以看到在谷歌新闻的自己上训练时，CBOW需要花费一天的时间，Skip-gram需要花费三天的时间。

 &emsp;&emsp; 在接下来的实验中，我们仅仅训练了一个epoch，实验结果如下

![1](https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89Word2Vec/1.png?raw=true)

### 4.4 Large Scale Parallel Training of Models

 &emsp;&emsp; 如前所述，我们已经在一个名为DistBelief的分布式框架中实现了各种模型。下面我们报告了在谷歌News  6B数据集上训练的几个模型的结果，这些模型使用了mini-batch异步梯度下降和自适应学习率程序，称为Adagrad[7]。我们在训练中使用了50到100个模型复制品。CPU核心的数量是估计得，因为数据中心机器还会与一些其他的任务共享，这种用法可能有比较大的波动。请注意，由于分布式框架的开销，CBOW模型和Skip-gram模型的CPU使用量比它们的单机实现要少得多。结果如表6所示。

![6](https://github.com/BaiDingHub/Blog_images/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/NLP%E8%AF%8D%E5%90%91%E9%87%8F%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89Word2Vec/6.png?raw=true)

### 4.5 Microsoft Research Sentence Completion Challenge

 &emsp;&emsp; The Microsoft Sentence Completion Challenge 是最近引入的一项任务，用于推进语言建模和其他NLP技术[32]。这项任务由1040个句子组成，每个句子都少一个单词，目标是选出与整个句子最连贯的单词，并给出5个合理的选择。几种技术的性能已经被报道，包括N-gram模型，基于LSA的模型[32]，对数双线性模型[24]和一种递归神经网络的组合，目前在这个SOTA[19]保持着55.4%的精度。

 &emsp;&emsp; 我们已经探讨了Skip-gram在此任务上的性能。首先，我们用[32]提供的50M单词训练640维模型。然后，我们使用输入的未知单词来计算测试集中每个句子的得分，并预测句子中周围的所有单词。最后一个句子的分数就是这些预测的总和。使用句子分数，我们选择最有可能的句子。

 &emsp;&emsp; 表7给出了一些以前的结果和新结果的简短总结。而Skip-gram模型本身在这个任务的表现不比LSA好，但是这个模型的分数与RNNLMs互补获得的分数，和加权组合会得到SOTA结果，58.9%的准确率。

## 5、Examples of the Learned Relationships0

 &emsp;&emsp; 表8显示了遵循各种关系的单词。我们遵循上面描述的方法:通过两个单词向量的详见来定义关系，然后将结果添加到另一个单词。例如，巴黎-法国+意大利=罗马。正如可以看到的，精度是相当好的，尽管有很多明显的进一步改进的空间(注意，使用我们自己的精确度度量标准，用来定义精准匹配程度，表8的准确度只达到了60%）。我们相信在更大维度的数据集上训练单词向量将会表现得更好，并且将会使开发的新应用程序成为可能。另一种提高准确性的方法是提供多个这种关系的例子。通过使用十个例子而不是一个例子来形成关系向量(我们将单个的向量平均起来)，我们观察到，在语义-句法测试中，我们最好的模型的准确性提高了大约10%。

 &emsp;&emsp; 用向量运算来解决不同的任务也是可行的。例如，通过计算单词列表的平均向量和查找最远的单词向量，我们观察到选择列表外单词的良好准确性。这是某些人类智力测试中常见的一类问题。显然，使用这些技术仍有很多发现有待发现。

## 6、Conclusion

 &emsp;&emsp; 在本文中，我们研究了在一个句法和语义语言任务集合上由各种模型派生的词向量representation的性能。我们观察到，与流行的神经网络模型(前馈和递归)相比，使用非常简单的模型架构可以训练高质量的词向量。由于更低的计算复杂度,可以使用一个更大的数据集来计算更加准确的高维向量，使用DistBelief分布式框架,可以在一万亿字的数据集上训练CBOW甚至Skip-gram模型，这基本相当于对数据集的词汇量数目不限制。这比之前发表的同类模型的最佳结果大了几个数量级。

 &emsp;&emsp; 一项有趣的任务是SemEval-2012任务2[11]，在这项任务中，词向量最近被证明明显优于之前的水平。将公开可用的RNN向量与其他技术一起使用，使得Spearman的秩相关性比之前的最佳结果[31]提高了50%以上。基于神经网络的词向量之前被应用于许多其他的NLP任务，例如情绪分析[12]和意译检测[28]。可以预期，这些应用可以受益于本文中描述的模型体系结构。

 &emsp;&emsp; 我们正在进行的工作表明，词向量可以成功地应用于知识库中事实的自动扩展，也可以用于验证现有事实的正确性。机器翻译实验的结果也很有希望。在将来，将我们的技术与潜在关系分析[30]和其他技术进行比较也是很有趣的。我们相信，我们的综合测试集将有助于研究社区改进现有的估计单词向量的技术。我们也期望高质量的词向量将成为未来自然语言处理应用的重要基石。